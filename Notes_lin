
git add .
git commit -m "Finish: new lexer"
git push origin lin
git push myrepo lin
#push my own
--------------------
git checkout main
git pull origin main
git merge lin
git add .
git commit -m ""
git push all
#merge and push to main
------------------------
REPL stands for Read-Eval-Print Loop:

Read: Read a line of input from the user.

Eval: Evaluate or process the input

Print: Output/echo the result.

Loop: Repeat this process for the next line, until you encounter EOF (Ctrl-D).
-------------------------
Ctrl-C in the terminal sends a SIGINT "interrupt" signal to the current program.
- Real shells do not quit when you press Ctrl-C while waiting for input, they just clear the line or print a new prompt.

Ctrl-\ sends a SIGQUIT "quit" signal.
-------------------------
// Test 1: Simple Command
Input: echo hello world
Expected:
[TOKEN_WORD:echo][TOKEN_WORD:hello][TOKEN_WORD:world]

// Test 2: Pipe and Redirection
Input: cat < file | grep foo > out.txt
Expected:
[TOKEN_WORD:cat][TOKEN_REDIR_IN:<][TOKEN_WORD:file][TOKEN_PIPE:|]
[TOKEN_WORD:grep][TOKEN_WORD:foo][TOKEN_REDIR_OUT:>][TOKEN_WORD:out.txt]

// Test 3: Strings Quoted with Single/Double Quotes
Input: echo "hello world" 'foo bar'
Expected:[TOKEN_WORD:echo][TOKEN_WORD:hello world:quoted=2][TOKEN_WORD:foo bar:quoted=1]

// Test 4: Operators Inside Quotes
Input: echo "a|b" | grep "c>d"
Expected:
[TOKEN_WORD:echo][TOKEN_WORD:a|b:quoted=2][TOKEN_PIPE:|]
[TOKEN_WORD:grep][TOKEN_WORD:c>d:quoted=2]

// Test 5: Escaped Characters
Input: echo \"hello\"
Expected:
[TOKEN_WORD:echo][TOKEN_WORD:"hello"]

// Test 6: Multiple Consecutive Operators
Input: cat << heredoc >> out
Expected:
[TOKEN_WORD:cat][TOKEN_HEREDOC:<<][TOKEN_WORD:heredoc]
[TOKEN_REDIR_APPEND:>>][TOKEN_WORD:out]

// Test 7: Only Spaces
Input: " "
Expected:
[TOKEN_WORD: :quoted=2]

// Test 8: Empty String
Input: (empty)
Expected:
(NULL or empty list)

// Test 9: Unclosed Quotes
Input: echo "hello world
Expected: Error or TOKEN_UNKNOWN (lexer should detect the error)

// Test 10: Token Containing Special Characters
Input: echo ab\$c
Expected:[TOKEN_WORD:echo][TOKEN_WORD:ab$c]
(The lexer should correctly interpret the escaped character)
-----------------------------"

void	*safe_malloc(size_t size)
{
	void *ptr;

	ptr = malloc(size);
	if (!ptr)
		exit_error("malloc failed\n");
	return (ptr);
}
------------------------
three issue:
1\safe malloc, fixed
2\strndup, fixed
3\tokenizer issue: the contents inside quotes are not being captured as a single token. Instead, they’re being split up or including stray quote characters.
---------------------

void print_redirects(t_redirect *redir)
{
    while (redir)
    {
        printf("  Redirect: type=%d, file=%s\n", redir->type, redir->filename);
        redir = redir->next;
    }
}

void print_cmd_list(t_cmd *cmd)
{
    int i, j = 0;
    while (cmd)
    {
        printf("=== Command #%d ===\n", ++j);
        printf("  argv:");
        for (i = 0; cmd->argv && cmd->argv[i]; i++))
            printf(" '%s'", cmd->argv[i]);
        printf("\n");
        print_redirects(cmd->redirects);
        cmd = cmd->next;
    }
}
-----------------
static void	print_token_list(t_token *token_list)
{
	int i = 0;
	while (token_list)
	{
		printf("Token %d: %s (type=%d) (quoted=%d)\n", i, token_list->str, token_list->t_type, token_list->quote_type);
		token_list = token_list->next;
		i++;
	}
}

void	repl_loop(void)
{
	char	*line;
	t_token	*token_list;

	while(1)
	{
		line = readline("minishell$ "); //should free line
		if (!line) //Ctrl+D
		{
			printf("exit\n");
			break ;
		}
		if(*line)
		{
			add_history(line); //no need to care about the history memory
			token_list = get_token_list(line);
			printf("You enter: %s\n", line);
			print_token_list(token_list);
			free_token_list(token_list);
			free(line);
		}
	}
}

int	main(void)
{
	setup_signals();
	repl_loop();
	return (0);
}
----------------------------
✅ When should you use perror?
File open/read/write errors (e.g., fopen, open, read, write fail)

Memory allocation failures (malloc, calloc, etc.)

System call failures (like fork, pipe, dup2, execve, etc.)

Any library/system function documented to set errno on failure

❌ When should you NOT use perror?
Logic errors in your own code that have nothing to do with system/library calls

Checking if a command string matches something (no error from a system call)

User input validation errors
------------------
!!!!!!!! should fix 0730;


9\can we use errno ??
10\
lin@EricdeMacBook-Pro minishell % cat out > wc -l
cat: -l: No such file or directory

lin@EricdeMacBook-Pro minishell % ./minishell
minishell$ cat out > wc -l
minishell: -l : command not found
minishell$ ^D%

---------------
need fix:

1\ if i delibrately embedded error in open heredoc file, i should press Ctrl+d twice to exit instead of exit directly, why??
minishell$ cat << 1
heredoc open failed: Bad address
minishell$ ^D%
2\
[父进程]
    |
    |--- pipe1[0/1]  (cat | grep)
    |--- fork -> [cat进程]
    |
    |--- pipe2[0/1]  (grep | wc)
    |--- fork -> [grep进程]
    |
    |--- fork -> [wc进程]
    |
    |--- 关闭所有pipe，只等wait

eg.		cat file.txt | grep foo | wc -l

每一轮循环父进程关闭/保留的 pipe fd
第一轮（cat）
父进程建 pipe1：[pipe1[0] (读), pipe1[1] (写)]

fork cat 进程

cat 子进程：

stdin = 默认

stdout = pipe1[1]（写入 pipe1，给 grep 用）

父进程操作：

prev_pipe == -1，什么都不关

有下一个命令（grep），所以：

close(pipe1[1]) 只关 pipe1 的写端（父进程自己不用写了！）

prev_pipe = pipe1[0]，把 pipe1[0]（读端）留给下一轮（grep 的 stdin）
->
第二轮（grep）
父进程建 pipe2：[pipe2[0] (读), pipe2[1] (写)]

fork grep 进程

grep 子进程：

stdin = prev_pipe = pipe1[0]

stdout = pipe2[1]

父进程操作：

prev_pipe == pipe1[0]，现在可以关掉 pipe1[0]（父进程自己不用了，baton 交完）

有下一个命令（wc），所以：

close(pipe2[1]) 只关 pipe2 的写端（父进程不用写）

prev_pipe = pipe2[0]，把 pipe2[0]（读端）留给下一轮（wc 的 stdin）
->
第三轮（wc）
没有新 pipe 了（这是最后一段）

fork wc 进程

wc 子进程：

stdin = prev_pipe = pipe2[0]

stdout = 1（终端）

父进程操作：

prev_pipe == pipe2[0]，现在可以关掉 pipe2[0]（baton 完全传递完）

没有下一个命令（这是最后一段），不需要新 pipe，prev_pipe = -1
---------
子进程只保留自己要用的那一头（输入/输出），其它全部及时关闭
------------

!!!should fix
1\
export and echo:

-export:
export
export 123=minishell
export foo

-echo:
echo -nnnn -nnnn -nnnn minishell

----------
父进程
  │
  ├── 调用 waitpid(pid, &status, 0)
  │
  ├── 等待子进程结束...
  │
  ├──[信号来了！]──► waitpid 被中断
  │                     │
  │                     ├── 返回值: -1
  │                     └── errno: EINTR (Interrupted system call)
  │
  ├── 检查: (返回值 == -1 && errno == EINTR) ?
  │         ├── 是 → 再次调用 waitpid (重试等待)
  │         └── 否 → 继续处理退出状态
  │
  ├── 最终拿到子进程状态
  │
  └── 根据 WIFEXITED / WIFSIGNALED 设置 exit_status

--------------
解析：单/双引号、转义、连续空格、结尾空格、管道/重定向组合、<< heredoc（含变量展开开关、Ctrl-C 取消、Ctrl-D 提前 EOF）。

展开：$VAR、$?、未定义变量、引号内/外的差异。

内建：

echo -n -nnn（连续 -n 应该也算数）、echo 的换行逻辑；

cd（无参、~、-、不存在路径/无权限时的返回码与环境更新）；

export（无参时的输出格式、排序、带或不带 = 的键处理）；

unset（不存在键不报错）；

env（只打印带值的环境）；

exit（无参、单参、非数字、多参时返回码与提示）。

执行与错误码：命令不存在=127、没有执行权限=126、把目录当可执行要报错。

信号：前台程序被 Ctrl-C/Ctrl-\ 终止时的消息与 $?，提示符下的互动。
--------------------
echo hello > out1 > out2
cat < infile > outfile
-----------
mimic the behavior of fork failed:
	errno = ENOMEM;
	pid = -1;

get_path, modify status
pipeline, modify fork failed, dup2 failed
single, modify fork failed
builtin, modify restore
------------------------------

Once execve() succeeds, it never returns. If it fails, you're already in a dying child, so:

✅ You do not need to call free_two(cmd, env_list) in the child, as long as the parent process will clean up everything later.


Memory in the child process is automatically cleaned up when it exits (no zombie mallocs). The only reason to free() manually in a child is if:

You're not using execve() and doing more logic.

Or you're looping/forking repeatedly without exiting (e.g., in a shell built-in).

But in your case — you're running execve(), then exiting. So no leak danger, and freeing is redundant.
