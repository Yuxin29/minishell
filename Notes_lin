
git add .
git commit -m "Finish: new lexer"
git push origin lin
git push myrepo lin
#push my own
--------------------
git checkout main
git pull origin main
git merge lin
git add .
git commit -m ""
git push all
#merge and push to main
------------------------
REPL stands for Read-Eval-Print Loop:

Read: Read a line of input from the user.

Eval: Evaluate or process the input

Print: Output/echo the result.

Loop: Repeat this process for the next line, until you encounter EOF (Ctrl-D).
-------------------------
Ctrl-C in the terminal sends a SIGINT "interrupt" signal to the current program.
- Real shells do not quit when you press Ctrl-C while waiting for input, they just clear the line or print a new prompt.

Ctrl-\ sends a SIGQUIT "quit" signal.
-------------------------
// Test 1: Simple Command
Input: echo hello world
Expected:
[TOKEN_WORD:echo][TOKEN_WORD:hello][TOKEN_WORD:world]

// Test 2: Pipe and Redirection
Input: cat < file | grep foo > out.txt
Expected:
[TOKEN_WORD:cat][TOKEN_REDIR_IN:<][TOKEN_WORD:file][TOKEN_PIPE:|]
[TOKEN_WORD:grep][TOKEN_WORD:foo][TOKEN_REDIR_OUT:>][TOKEN_WORD:out.txt]

// Test 3: Strings Quoted with Single/Double Quotes
Input: echo "hello world" 'foo bar'
Expected:[TOKEN_WORD:echo][TOKEN_WORD:hello world:quoted=2][TOKEN_WORD:foo bar:quoted=1]

// Test 4: Operators Inside Quotes
Input: echo "a|b" | grep "c>d"
Expected:
[TOKEN_WORD:echo][TOKEN_WORD:a|b:quoted=2][TOKEN_PIPE:|]
[TOKEN_WORD:grep][TOKEN_WORD:c>d:quoted=2]

// Test 5: Escaped Characters
Input: echo \"hello\"
Expected:
[TOKEN_WORD:echo][TOKEN_WORD:"hello"]

// Test 6: Multiple Consecutive Operators
Input: cat << heredoc >> out
Expected:
[TOKEN_WORD:cat][TOKEN_HEREDOC:<<][TOKEN_WORD:heredoc]
[TOKEN_REDIR_APPEND:>>][TOKEN_WORD:out]

// Test 7: Only Spaces
Input: " "
Expected:
[TOKEN_WORD: :quoted=2]

// Test 8: Empty String
Input: (empty)
Expected:
(NULL or empty list)

// Test 9: Unclosed Quotes
Input: echo "hello world
Expected: Error or TOKEN_UNKNOWN (lexer should detect the error)

// Test 10: Token Containing Special Characters
Input: echo ab\$c
Expected:[TOKEN_WORD:echo][TOKEN_WORD:ab$c]
(The lexer should correctly interpret the escaped character)
-----------------------------"

void	*safe_malloc(size_t size)
{
	void *ptr;

	ptr = malloc(size);
	if (!ptr)
		exit_error("malloc failed\n");
	return (ptr);
}
------------------------
three issue:
1\safe malloc, fixed
2\strndup, fixed
3\tokenizer issue: the contents inside quotes are not being captured as a single token. Instead, they’re being split up or including stray quote characters.
---------------------

void print_redirects(t_redirect *redir)
{
    while (redir)
    {
        printf("  Redirect: type=%d, file=%s\n", redir->type, redir->filename);
        redir = redir->next;
    }
}

void print_cmd_list(t_cmd *cmd)
{
    int i, j = 0;
    while (cmd)
    {
        printf("=== Command #%d ===\n", ++j);
        printf("  argv:");
        for (i = 0; cmd->argv && cmd->argv[i]; i++)
            printf(" '%s'", cmd->argv[i]);
        printf("\n");
        print_redirects(cmd->redirects);
        cmd = cmd->next;
    }
}
-----------------
static void	print_token_list(t_token *token_list)
{
	int i = 0;
	while (token_list)
	{
		printf("Token %d: %s (type=%d) (quoted=%d)\n", i, token_list->str, token_list->t_type, token_list->quote_type);
		token_list = token_list->next;
		i++;
	}
}

void	repl_loop(void)
{
	char	*line;
	t_token	*token_list;

	while(1)
	{
		line = readline("minishell$ "); //should free line
		if (!line) //Ctrl+D
		{
			printf("exit\n");
			break ;
		}
		if(*line)
		{
			add_history(line); //no need to care about the history memory
			token_list = get_token_list(line);
			printf("You enter: %s\n", line);
			print_token_list(token_list);
			free_token_list(token_list);
			free(line);
		}
	}
}

int	main(void)
{
	setup_signals();
	repl_loop();
	return (0);
}
-------------
Edge Case Table for Parser Error Testing

`	ls`	Starts with pipe
`ls		wc`
`ls	`	Ends with pipe
ls >	Redirection with no target	Syntax error
ls <	Redirection with no target	Syntax error
cat < > out.txt	Redirection missing filename	Syntax error
ls > < out.txt	Multiple redirects with missing target	Syntax error
echo "foo	Unclosed quote	Syntax error or unterminated error
echo 'foo	Unclosed quote	Syntax error or unterminated error
`ls >	wc`	Redirect, then pipe, missing filename
`ls <	wc`	Input redirect, then pipe, no filename
`` (empty input)	Blank line	Do nothing / no command
cat <<	Heredoc with no delimiter	Syntax error
cat << EOF (unterminated heredoc in script mode)	Heredoc with missing content	Error or warning
ls > > out.txt	Two > with no filename in between	Syntax error
ls < in.txt >	Redirect out with missing filename	Syntax error
ls "foo	Unclosed double quote	Syntax error
ls 'foo	Unclosed single quote	Syntax error
----------------------------
✅ When should you use perror?
File open/read/write errors (e.g., fopen, open, read, write fail)

Memory allocation failures (malloc, calloc, etc.)

System call failures (like fork, pipe, dup2, execve, etc.)

Any library/system function documented to set errno on failure

❌ When should you NOT use perror?
Logic errors in your own code that have nothing to do with system/library calls

Checking if a command string matches something (no error from a system call)

User input validation errors
------------------
!!!!!!!! should fix 0730;
1\ also check in lex and parce, can not exit directly, otherwise there is no chance to free the thing we've already malloced. (check_strndup(NULL, cmd, tokens) in parsing)
3\ same in execute, do not exit directly(except in child process)
4\ should not exit if the user types a non-existent command like cati Makefile, They only exit if the user types exit, sends an EOF (Ctrl+D), or if there is a critical internal error. so shoul use globle var
5\in this case, continue or exit??
			exec_cmd.whole_cmd = build_command_list(token_list);
			free_token_list(token_list);
			if (!exec_cmd.whole_cmd)
			{
				free_env_list(env_list);
				ft_free_arr(exec_cmd.envp);
				ft_putstr_fd("Error: build command list failed\n", 2);
				g_exit_status = 1;
				continue;
				//exit(EXIT_FAILURE);
			}
7\ changed parse (t_type == 5), but should rewrite and cannot exit
8\ run echo "hello  ,some memory problen happened
9\can we use errno ??
10\
lin@EricdeMacBook-Pro minishell % cat out > wc -l
cat: -l: No such file or directory

lin@EricdeMacBook-Pro minishell % ./minishell
minishell$ cat out > wc -l
minishell: -l : command not found
minishell$ ^D%
11\  cat < in < out
lin@EricdeMacBook-Pro minishell % cat < in < out
zsh: no such file or directory: in

lin@EricdeMacBook-Pro minishell % make
lin@EricdeMacBook-Pro minishell % ./minishell
minishell$ cat < in < out
out: No such file or directory
$
--------------------------------------

typedef struct s_redir
{
	char            *file;
	int                type; // T_REDIRECT_IN 2, T_REDIRECT_OUT 3, T_APPEND 4, T_HEREDOC 5
	struct s_redir    *next;
}	t_redir;

typedef struct s_cmd
{
	char            **argv;
	t_redir            *redirections;  // <-- list of redirections
	struct s_cmd    *next;
}	t_cmd;
-----------------------

void	apply_redirections(t_redir_info *redir)
{
	int	fd;

	while (redir)
	{
		if (redir->type == REDIR_IN)
		{
			fd = open(redir->filename, O_RDONLY);
			if (fd < 0)
				exit_with_error("infile open fail");
			dup2(fd, STDIN_FILENO);
			close(fd);
		}
		else if (redir->type == REDIR_OUT || redir->type == REDIR_APPEND)
		{
			int flags = O_WRONLY | O_CREAT |
				((redir->type == REDIR_APPEND) ? O_APPEND : O_TRUNC);
			fd = open(redir->filename, flags, 0644);
			if (fd < 0)
				exit_with_error("outfile open fail");

			if (redir->next == NULL ||
				!(redir->next->type == REDIR_OUT || redir->next->type == REDIR_APPEND))
			{
				dup2(fd, STDOUT_FILENO);
			}
			close(fd);
		}
		redir = redir->next;
	}
}
--------------
modify return msg in get_path(use perror to print first)
---------------
	if (tokens->t_type == 5)
	{
		if (cmd->infile)
			free(cmd->infile);
		if (cmd->heredoc_delim)
			free(cmd->heredoc_delim);
		cmd->heredoc_delim = ft_strdup(next->str);
		if (!cmd->heredoc_delim)
			return (NULL);
		tmpfile = creat_heredoc_file(cmd->heredoc_delim);
		if (!tmpfile)
			return (NULL);
		cmd->infile = tmpfile;
	}
