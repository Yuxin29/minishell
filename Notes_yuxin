
=================================git collaborations=====================================================
//how to work in your branch and push to the main
	- git checkout branch-name
	- do changes
	- git add .
	- git commit -m "changes"
	- git push origin branch_name
----------------------------------------
	- git checkout main
	- git pull origin main
	- git merge branch_name
	- git add .
	- git commit -m "changes merge to main"
	- git push origin main


=================================minishell workflows=====================================================
main.c         --->  +---------------------------------------------+
üë§üë§ Shared          | init env from envp                          | -> void init_env(char **envp);
                     | init signal handlers                        | -> void setup_signals(void);
                     | shell loop:                                 |
                     |   - readline prompt                         | -> char *read_input(void);
                     |   - pass line to parser                     | -> t_cmd *parse_line(char *line);
                     |   - execute command list                    | -> void execute_commands(t_cmd *cmds, t_env *env);
                     |   - clean up & wait                         | -> void cleanup_shell(t_cmd *cmds);
                     | exit: free everything                       | -> void free_everything(t_cmd *cmds, t_env *env);
                     +---------------------------------------------+
                                        |
                                        v
lexer.c        --->  +---------------------------------------------
üë§ A                 | split line into tokens                      | -> t_token *get_tokens(char *line);
                     | handle quotes, escapes                      | -> char *extract_quoted(char *line, int *i);
                     | classify token types                        | -> t_token_type get_token_type(const char *str);
                     | return token list                           | (same as get_tokens)
                     +---------------------------------------------+
                                        |
                                        v
parser.c       --->  +---------------------------------------------+
üë§ A                 | syntax check (pipes, etc.)                  | -> int check_syntax(t_token *tokens);
                     | build command structures                    | -> t_cmd *build_command_list(t_token *tokens);
                     | handle redirections                         | -> void parse_redirections(t_cmd *cmd, t_token **tokens);
                     | group commands by pipe                      | -> t_cmd *group_by_pipes(t_token *tokens);
                     | return exec-ready tree                      | (same as build_command_list)
                     +---------------------------------------------+
                                        |
                                        v
expander.c    --->   +---------------------------------------------+
üë§ A                 | expand $VARIABLEs                           | -> char *expand_variables(char *str, t_env *env);
                     | handle $? and special vars                  | -> char *expand_special_vars(char *str, int last_exit);
                     | apply quote rules                           | -> char *remove_quotes(char *str);
                     +---------------------------------------------+
                                        |
                                        v
executor.c    --->   +---------------------------------------------+
üë§ B                 | for each command:                           |
                     |   - fork child                              | -> pid_t fork_and_execute(t_cmd *cmd, t_env *env);
                     |   - set up redirs & pipes                   | -> void setup_redirections(t_cmd *cmd);
                     |   - execve or builtin call                  | -> int execute_builtin_or_exec(t_cmd *cmd, t_env *env);
                     | parent: wait for children                   | -> int wait_for_children(void);
                     +---------------------------------------------+
                                        |
        ----------------------+----------------------
        |                                              |
builtins.c    --->  +-------------------------------+     env.c --->  +--------------------------------+
üë§ B                | cd, echo, pwd, etc            |  üë§ B                | env list init & update          |
                    |                               |                 | -> t_env *init_env_list(char **envp);
                    | -> int builtin_cd(char **args, t_env *env); |   | -> void update_env(t_env **env, const char *key, const char *val);
                    | -> int builtin_echo(char **args);           |   | export/unset logic             |
                    | -> int builtin_pwd(void);                   |   | -> int builtin_export(char **args, t_env **env);
                    | exit (in parent)                            |   | -> int builtin_unset(char **args, t_env **env);
                    | -> int builtin_exit(char **args);           |   | -> char **env_to_envp_array(t_env *env);
                    +-------------------------------+             +--------------------------------+
                                        |
                                        v
signals.c     --->   +---------------------------------------------+
üë§üë§ Shared          | SIGINT: handle Ctrl+C                       | -> void sigint_handler(int signo);
                     | SIGQUIT: ignore or handle                   | -> void sigquit_handler(int signo);
                     | restore terminal state                      | -> void restore_terminal_settings(void);
                     +---------------------------------------------+
                                        |
                                        v
utils.c       --->   +---------------------------------------------+
üë§üë§ Shared                      | error printing                  | -> void print_error(const char *msg);
                     | memory management helpers                   | -> void *safe_malloc(size_t size);
                     | free token/cmd/env structs                  | -> void free_tokens(t_token *head);
                     |                                             | -> void free_commands(t_cmd *cmds);
                     |                                             | -> void free_env(t_env *env);
                     +---------------------------------------------+


** Error exit codes:

    - Syntax error:         exit 2
    - Command not found:    exit 127
    - Permission denied:    exit 126
    - Signal exit (e.g. ^C): appropriate status
    - Builtin exit:         user-defined exit code

=================================concept in parsing=====================================================

prompt: A prompt in a shell is the text displayed to the user that signals it's ready to receive input.
for example:        -bash       user@hostname:~$
                    -minishell  minishell$

lexing and token
lexing  - a process the analyse the raw line and change it to tokens
token   - the results of the smallest unit

"  " and '   '
'single quotes'     literally just a string
"double quotes"     possibly multiple variables and commands included

====================================for example====================================
echo "hello world" > file.txt | cat -e
[TOKEN: echo]	[TOKEN: "hello world"]	[TOKEN: >]	[TOKEN: file.txt]   [TOKEN: |] 	[TOKEN: cat]  	[TOKEN: -e]
T_WORD	  				T_WORD		T_REDIRECT_OUT		 T_WORD			  T_PIPE	   T_WORD		  T_WORD
--------------------------------------------------------------------------------------
t_cmd *cmd_list = cmd1;
cmd1:
argv:        ["echo", "hello world", NULL]
infile:      NULL
outfile:     "file.txt"
append_out:  0
heredoc_delim: NULL
next:        -> cmd2
-----------------------------------------------
cmd2:
argv:        ["cat", "-e", NULL]
infile:      NULL
outfile:     NULL
append_out:  0
heredoc_delim: NULL
next:        NULL

=================================to tell lin on Friday  =====================================================

in lex_utils.c, we are prechecking if quotes are closed or not
//in case of the quotes not close, the screen is blicking because it thinks that the cmd is not finished
mikko@mikko-desktop-ubuntu:~/yuxin_home/minishell$ cat < input.txt | grep foo > out.txt | echo "hello world 'again' >> out2.txt
> ^C
mikko@mikko-desktop-ubuntu:~/yuxin_home/minishell$ cat < input.txt | grep foo > out.txt | echo "hello world
> "
hello world

bash: input.txt: No such file or directory

| cat Makefile
this syntax error is reported before change token to cmd list
cat Makefile or Cati makefile
the cmd existence and file access if reported after parsing

Phase	        Checks file existence?	         Errors?
Lexing	        ‚ùå No	                        Only syntax / quoting issues
Parsing	        ‚ùå No	                        Only invalid structure, like `
Execution	    ‚úÖ Yes	                        File not found, command not found, etc.

=================================about environment variables =====================================================
how to set env_variables, in bash eg:
export VAR=value
//do we need to achieve this export in shell as well?

EDGE CASES AND TESTS
Input                   Expected Output
"Hello $USER"	        "Hello alice"
'Hello $USER'	        'Hello $USER'
"Path is $PATH/bin"	    "Path is /usr/bin:/bin/bin"
"$"	                    "" (empty string or preserved as literal)
"$UNDEFINED"	        ""
"Mix$VAR1and$VAR2"	    "Mixval1andval2"

how to set env_variables, in bash eg:
export VAR=value
//do we need to achieve this export in shell as well? tes

EDGE CASES AND TESTS
Input                   Expected Output
"Hello $USER"	        "Hello alice"
'Hello $USER'	        'Hello $USER'
"Path is $PATH/bin"	    "Path is /usr/bin:/bin/bin"
"$"	                    "" (empty string or preserved as literal)
"$UNDEFINED"	        ""
"Mix$VAR1and$VAR2"	    "Mixval1andval2"

=================================weird testing case=====================================================
//about quotes and #USER
echo "yuxin $USER '$USER' "user" kk,"
echo "hello "yuxin" wi"
echo 'hello 'yuxin' wi'
echo "hello 'yuxin' wi"
echo 'hello "yuxin" wi'

//about redirection
< infile            bash: infile: No such file or directory, fake excution
cat <               bash: syntax error near unexpected token 'newline', exit during parsing stage

//cmds without empty space in between
echo$USER           bash: echoyuwu: command not found
cat<Makefile        bash: solid, same as cat < Makefile
