
====================================================================git collaborations=========================================================================
//how to work in your branch and push to the main
	- git checkout branch-name
	- do changes
	- git add .
	- git commit -m "changes"
	- git push origin branch_name
----------------------------------------
	- git checkout main
	- git pull origin main
	- git merge branch_name
	- git add .
	- git commit -m "changes merge to main"
	- git push origin main


===========================================================minishell workflows=========================================================================
main.c         --->  +---------------------------------------------+
ğŸ‘¤ğŸ‘¤ Shared          | init env from envp                          | -> void init_env(char **envp);
                     | init signal handlers                        | -> void setup_signals(void);
                     | shell loop:                                 |
                     |   - readline prompt                         | -> char *read_input(void);
                     |   - pass line to parser                     | -> t_cmd *parse_line(char *line);
                     |   - execute command list                    | -> void execute_commands(t_cmd *cmds, t_env *env);
                     |   - clean up & wait                         | -> void cleanup_shell(t_cmd *cmds);
                     | exit: free everything                       | -> void free_everything(t_cmd *cmds, t_env *env);
                     +---------------------------------------------+
                                        |
                                        v
lexer.c        --->  +---------------------------------------------
ğŸ‘¤ A                 | split line into tokens                      | -> t_token *get_tokens(char *line);
                     | handle quotes, escapes                      | -> char *extract_quoted(char *line, int *i);
                     | classify token types                        | -> t_token_type get_token_type(const char *str);
                     | return token list                           | (same as get_tokens)
                     +---------------------------------------------+
                                        |
                                        v
parser.c       --->  +---------------------------------------------+
ğŸ‘¤ A                 | syntax check (pipes, etc.)                  | -> int check_syntax(t_token *tokens);
                     | build command structures                    | -> t_cmd *build_command_list(t_token *tokens);
                     | handle redirections                         | -> void parse_redirections(t_cmd *cmd, t_token **tokens);
                     | group commands by pipe                      | -> t_cmd *group_by_pipes(t_token *tokens);
                     | return exec-ready tree                      | (same as build_command_list)
                     +---------------------------------------------+
                                        |
                                        v
expander.c    --->   +---------------------------------------------+
ğŸ‘¤ A                 | expand $VARIABLEs                           | -> char *expand_variables(char *str, t_env *env);
                     | handle $? and special vars                  | -> char *expand_special_vars(char *str, int last_exit);
                     | apply quote rules                           | -> char *remove_quotes(char *str);
                     +---------------------------------------------+
                                        |
                                        v
executor.c    --->   +---------------------------------------------+
ğŸ‘¤ B                 | for each command:                           |
                     |   - fork child                              | -> pid_t fork_and_execute(t_cmd *cmd, t_env *env);
                     |   - set up redirs & pipes                   | -> void setup_redirections(t_cmd *cmd);
                     |   - execve or builtin call                  | -> int execute_builtin_or_exec(t_cmd *cmd, t_env *env);
                     | parent: wait for children                   | -> int wait_for_children(void);
                     +---------------------------------------------+
                                        |
        ----------------------+----------------------
        |                                              |
builtins.c    --->  +-------------------------------+     env.c --->  +--------------------------------+
ğŸ‘¤ B                | cd, echo, pwd, etc            |  ğŸ‘¤ B                | env list init & update          |
                    |                               |                 | -> t_env *init_env_list(char **envp);
                    | -> int builtin_cd(char **args, t_env *env); |   | -> void update_env(t_env **env, const char *key, const char *val);
                    | -> int builtin_echo(char **args);           |   | export/unset logic             |
                    | -> int builtin_pwd(void);                   |   | -> int builtin_export(char **args, t_env **env);
                    | exit (in parent)                            |   | -> int builtin_unset(char **args, t_env **env);
                    | -> int builtin_exit(char **args);           |   | -> char **env_to_envp_array(t_env *env);
                    +-------------------------------+             +--------------------------------+
                                        |
                                        v
signals.c     --->   +---------------------------------------------+
ğŸ‘¤ğŸ‘¤ Shared          | SIGINT: handle Ctrl+C                       | -> void sigint_handler(int signo);
                     | SIGQUIT: ignore or handle                   | -> void sigquit_handler(int signo);
                     | restore terminal state                      | -> void restore_terminal_settings(void);
                     +---------------------------------------------+
                                        |
                                        v
utils.c       --->   +---------------------------------------------+
ğŸ‘¤ğŸ‘¤ Shared                      | error printing                  | -> void print_error(const char *msg);
                     | memory management helpers                   | -> void *safe_malloc(size_t size);
                     | free token/cmd/env structs                  | -> void free_tokens(t_token *head);
                     |                                             | -> void free_commands(t_cmd *cmds);
                     |                                             | -> void free_env(t_env *env);
                     +---------------------------------------------+


** Error exit codes:

    - Syntax error:             exit 2
    - Command not found:        exit 127
    - Permission denied:        exit 126
    - Signal exit (e.g. ^C):    appropriate status: like 128 + status
    - Builtin exit:             user-defined exit code

==============================================================concept in parsing==================================================================================

-------> prompt: A prompt in a shell is the text displayed to the user that signals it's ready to receive input.
for example:        -bash       user@hostname:~$
                    -minishell  minishell$

-------> lexing and token
lexing  - a process the analyse the raw line and change it to tokens
token   - the results of the smallest unit

-------> "  " and '   '
        'single quotes'     literally just a string
        "double quotes"     possibly multiple variables and commands included

-------> Error msg in different phase  
Phase	        Checks file existence?	          Errors?
Lexing	        No	                              Only special character and unclosed quotes
Parsing	        No	                              Only invalid structure
Execution	    Yes	                              File not found, command not found, etc.

========================================================continous redirections should be allowd ===========================================================
----->  example case
    ->  echo > out1 > out2 > out3
    ->  cat < in1 < in2 < in3
    ->  cat < file1 > file2 < file1: does this make sense: should we handle it?
    ->  cat < in.txt > out.txtThis reads from in.txt and writes to out.txt.
    ->  grep hello < file.txt > result.txt, grep hello from infile and put it to a outfile

----->  to handles this, we have redirection node as a linked list
typedef struct s_redir {
	char *file;
	int type; // T_REDIRECT_IN, T_REDIRECT_OUT, T_APPEND, T_HEREDOC
	struct s_redir *next;
} t_redir;

typedef struct s_cmd
{
	char **argv;
	t_redir *redirections;  // <-- list of redirections
	struct s_cmd *next;
} t_cmd;

-----> more infor about bash behaviors of continous refirection
    - In real Bash, even though only the last redirection affects where the command reads/writes
    - all redirections are processed in order, and errors can occur during any redirection (not just the last).
    - in one cmd, redirectin, redirectout, append and heredoc can appear at the same time for multiple times


=================================================================PARSEING for example=================================================================
echo "hello world" > file.txt | cat -e
[TOKEN: echo]	[TOKEN: "hello world"]	[TOKEN: >]	[TOKEN: file.txt]   [TOKEN: |] 	[TOKEN: cat]  	[TOKEN: -e]
T_WORD	  				T_WORD		T_REDIRECT_OUT		 T_WORD			  T_PIPE	   T_WORD		  T_WORD
--------------------------------------------------------------------------------------
t_cmd *cmd_list = cmd1;
cmd1:
argv:        ["echo", "hello world", NULL]
infile:      NULL
outfile:     "file.txt"
append_out:  0
heredoc_delim: NULL
next:        -> cmd2
-----------------------------------------------
cmd2:
argv:        ["cat", "-e", NULL]
infile:      NULL
outfile:     NULL
append_out:  0
heredoc_delim: NULL
next:        NULL

========================================expand raw line vs expand AST/é“¾è¡¨=========================================


â€œé¢„å±•å¼€ raw lineï¼ˆæ•´è¡Œæ‰«æé¢„å¤„ç†ï¼‰â€

âœ…  ä¼˜ç‚¹
- åœ¨è¯æ³•åˆ†æå‰å°±æŠŠ $VAR / $? ç­‰æ›¿æ¢æ‰ï¼Œåé¢ parser æ›´ç®€å•ã€‚
- å¯¹â€œé¢„ä¿å­˜å‘½ä»¤â€è¿™ç±»éœ€æ±‚ï¼ˆä½ æåˆ°çš„ $A="echo hello"ï¼‰å¯ä»¥ä¸€æ¬¡æ€§æ‘Šå¹³

âš ï¸ ç¼ºç‚¹ï¼ˆå…³é”®ï¼‰
- ä¼šå’Œè¯­æ³•/å¼•å·/æ“ä½œç¬¦è¾¹ç•Œæ‰“æ¶ï¼Œå°¤å…¶æ˜¯ << ä¹‹åçš„heredoc å®šç•Œç¬¦ï¼šå®šç•Œç¬¦ä¸èƒ½åšå˜é‡å±•å¼€ï¼Œè€Œä¸”æ˜¯å¦å±•å¼€ heredoc æ­£æ–‡æ˜¯ç”±å®šç•Œç¬¦æ˜¯å¦åŒ…å«å¼•å·æ¥å†³å®šçš„ï¼ˆæœ‰å¼•å·â†’ä¸å±•å¼€ï¼Œæ— å¼•å·â†’å±•å¼€ï¼‰ã€‚
- æ‹¿ä½ çš„å¤±è´¥ç”¨ä¾‹ << $ABC"" æ¥è¯´ï¼š
  ä½ å½“å‰ä»£ç åœ¨çœ‹åˆ° << åä¸€é‡åˆ°ç©ºæ ¼å°±ç»“æŸâ€œè·³è¿‡å±•å¼€â€çŠ¶æ€ï¼Œå¯¼è‡´åé¢çš„ $ABC"" è¢«é”™è¯¯åœ°å±•å¼€äº†â€”â€”è¿™æ˜¯ä¸å…è®¸çš„ã€‚å®šç•Œç¬¦æ˜¯ä¸€ä¸ªå®Œæ•´çš„â€œè¯â€ï¼ˆwordï¼‰ï¼Œ
  å¿…é¡»æŠŠè¿™ä¸ªè¯æŒ‰å¼•å·æ„ŸçŸ¥çš„è§„åˆ™ä¸€æ¬¡æ€§è¯»å®Œï¼Œå†æ¢å¤æ­£å¸¸å±•å¼€ã€‚
- è¿˜ä¼šç‰µæ¶‰ <<<ã€<<- ç­‰è¾¹è§’ï¼ˆ42 ä¸€èˆ¬ä¸è¦æ±‚ï¼Œä½†å®¹æ˜“è¸©ï¼‰ã€‚

â€œå…ˆè¯æ³•/è¯­æ³•â†’å†å¯¹ token/AST åšå±•å¼€ï¼ˆæ¨èï¼‰â€
âœ…  ä¼˜ç‚¹ï¼ˆæ›´è´´è¿‘ Bashï¼‰
å…ˆæŠŠè¾“å…¥åˆ‡æˆæ“ä½œç¬¦ï¼ˆ| < > << >>ï¼‰å’Œè¯ï¼ˆå«å¼•å·ä¿¡æ¯ï¼‰ï¼Œå»æ‰è¯å†…çš„å¼•å·ï¼ˆquote removalï¼‰ï¼Œç„¶åï¼š
- å¯¹ argvã€é‡å®šå‘æ–‡ä»¶åç­‰åšå‚æ•°å±•å¼€ï¼ˆå•å¼•å·å†…ä¸å±•å¼€ã€åŒå¼•å·å†…å¯å±•å¼€ï¼‰ã€‚
- å¯¹ << çš„ä¸‹ä¸€ä¸ªè¯ï¼ˆå®šç•Œç¬¦ï¼‰åªåšquote removalï¼Œä¸åšå˜é‡å±•å¼€ï¼›åŒæ—¶è®°å½•ä¸€ä¸ªå¸ƒå°”ä½â€œå®šç•Œç¬¦æ˜¯å¦å¸¦å¼•å·â€ã€‚
- è¯» heredoc æ­£æ–‡æ—¶ï¼Œè‹¥â€œå®šç•Œç¬¦å¸¦å¼•å·â€â†’æ­£æ–‡ä¸åšä»»ä½•å±•å¼€ï¼›è‹¥ä¸å¸¦å¼•å·â†’æ­£æ–‡è¿›è¡Œå‚æ•°/å‘½ä»¤/ç®—æœ¯ï¼ˆä½ é¡¹ç›®ä¸€èˆ¬åªåš $VAR å’Œ $?ï¼‰å±•å¼€ã€‚
- ä¸å®¹æ˜“å’Œè¯­æ³•æ‰“æ¶ï¼Œè¡Œä¸ºå’Œ Bash ä¸€è‡´ã€‚

âš ï¸ ç¼ºç‚¹
- parser è¦ä¿å­˜æ›´å¤šå…ƒä¿¡æ¯ï¼ˆæ¯”å¦‚â€œè¿™ä¸ª heredoc çš„ delimiter æ˜¯å¦å¸¦è¿‡å¼•å·â€ï¼‰ã€‚
- ç¨å¾®å¤šå†™ä¸€ç‚¹ä»£ç ï¼Œä½†ä¸€æ¬¡å†™å¯¹åæœŸæœ€çœå¿ƒã€‚

I chose preexpandingh


================================================================PARSEING test case Specail ====================================================
âŒâŒâŒ what need  to be fixed
âš ï¸âš ï¸âš ï¸ differs, but I dont think it need to be fixed

----------------> Prespanding
1. preexpading is needed, for cmd as VAR
    ->  export $CMD="echo hello"
        $CMD
    preexpading is needed, also for VAR can mess up with cmd
    ->  echo$USER           bash: echoyuwu: command not found

2. normal expansion case
    ->  minishell$ echo "$USER "$USER" '$USER'" '$USER' "$USER"
        echo "Hello $USER"	                    "Hello alice"
        echo 'Hello $USER'	                    'Hello $USER'
        echo "Path is $PATH/bin"	            "Path is /usr/bin:/bin/bin"
        echo "$"	                            "" (empty string or preserved as literal)
        echo "$UNDEFINED"	                    ""
        echo "Mix$VAR1and$VAR2"	                "Mixval1andval2" 
        echo "yuxin $USER '$USER' "user" kk,"

3. heredoc without quotes should be expanded 
    ->  minishell$ echo << $USER                    
        > skfd
        > mikko
        > $USER
    ->  minishell$ echo << $SUER                    
        minishell: syntax error: missing filename or delimiter after redirection

4. heredoc with quotes should not be expanded        
    mikko@mikko-desktop-ubuntu:~/yuxin_home/minishell$ cat << ""$USER
    > asd
    > sdfg
    > mikko
    > $USER
    asd
    sdfg
    mikko
    mikko@mikko-desktop-ubuntu:~/yuxin_home/minishell$ ./minishell 
    minishell$ cat << ""$USER
    minishell heredoc> sdf
    minishell heredoc> mikko
    sdf

5. heredoc with quotes should not be expanded              same as above
    yuwu@c2r6p13:~$ echo << $ABC"" | grep abc
    > $USER
    > abc sdfkljsdfkjl
    > $USER"abc"
    > fgjkfgjk
    > fgkljfghklj
    > abcok
    > $ABC
    yuwu@c2r6p13:~$ cat << $ABC"" | grep abc
    $USER
    abc sdfkljsdfkjl
    $USER"abc"
    fgjkfgjk
    fgkljfghklj
    abcok
    $ABC
    abc sdfkljsdfkjl
    $USER"abc"
    abcok

    -> âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸ one more test case âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸
    cat << $""USER
    
6. multiple $, or ""
    mikko@mikko-desktop-ubuntu:~/yuxin_home/minishell$ echo $
    $
    mikko@mikko-desktop-ubuntu:~/yuxin_home/minishell$ echo "$"$
    $$
    mikko@mikko-desktop-ubuntu:~/yuxin_home/minishell$ echo "$"$"$"
    $$
    mikko@mikko-desktop-ubuntu:~/yuxin_home/minishell$ echo "$" $ "$"
    $ $ $
    mikko@mikko-desktop-ubuntu:~/yuxin_home/minishell$ echo "$"$ "$"
    $$ $
    mikko@mikko-desktop-ubuntu:~/yuxin_home/minishell$ echo "$"$$"$" âš ï¸
    $217485$
    mikko@mikko-desktop-ubuntu:~/yuxin_home/minishell$ echo $? $$ âš ï¸
    0 217485
    mikko@mikko-desktop-ubuntu:~/yuxin_home/minishell$ echo $?$$ âš ï¸
    0217485
    mikko@mikko-desktop-ubuntu:~/yuxin_home/minishell$ echo $?$?"$"$?"$" âš ï¸
    00$0$
    mikko@mikko-desktop-ubuntu:~/yuxin_home/minishell$ echo $?$?"$"$?$"$" âš ï¸
    00$0$

7. first export our own VAR, and then echo $VAR, with / without -n, with / without quotes
    yuwu@c2r6p13:~/42/Rank3_minishell$ export A="     a       b     "
    yuwu@c2r6p13:~/42/Rank3_minishell$ echo $A
    a b
    yuwu@c2r6p13:~/42/Rank3_minishell$ echo -n $A
    a b
    yuwu@c2r6p13:~/42/Rank3_minishell$ echo -n "$A"
        a       b     
    yuwu@c2r6p13:~/42/Rank3_minishell$ echo "$A"
        a       b     

----------------> Parsing
1. "<" and '<' should be solid input argv, but < is certainly redirect int
    ->  echo "<"
    ->  echo "<"<<"<"
    ->  echo "<<"<<"<<"
    ->  echo '>>'

2. first redirections and then actuall command is valid in bash    
    -> > out.txt echo hello       
    -> echo hello > out.txt       this one is working
    -> echo > out.txt hello     this one is working

3. about quotes
    ->  echo "hello "yuxin" wi"
        echo 'hello 'yuxin' wi'
        echo "hello 'yuxin' wi"
        echo 'hello "yuxin" wi'

4.  empty string executions 
    ->  minishell$ ""
        Command '' not found,

5. a cmd can have null as argv, just redirection
    ->  cat Makefile | < in
    ->  < in

----------------> build in
1. cd
    ->  cd without argv[1] means change home
2. exit
    yuwu@c2r4p10:~$ exit 1 1
    exit
    bash: exit: too many arguments
    yuwu@c2r4p10:~$ exit a 1
    exit
    bash: exit: a: numeric argument required
    c2r4p10% bash
    yuwu@c2r4p10:~$ exit 1
    exit
    c2r4p10% bash
    yuwu@c2r4p10:~$ exit 1111111111111111111111111111111
    exit
    bash: exit: 1111111111111111111111111111111: numeric argument required
    c2r4p10% bash    
    yuwu@c2r4p10:~$ exit 300
    exit
    c2r4p10% echo  $?
    44
    c2r4p10% 300-256
    zsh: command not found: 300-256
3. export
    ->  export has to have valid varaiable name
        ->   export 77="1 2 3"
4. echo
    -> -n or not -n
        yuwu@c2r4p10:~$ echo -nnnnnnn 123
        123yuwu@c2r4p10:~$ echo -nnnnnnn -nnnnn -n -nnnn 123
        123yuwu@c2r4p10:~$ echo -nnnnnnn -nnnnn -n -nnnn -n-n 123
        -n-n 123yuwu@c2r4p10:~$ pwd
        /home/yuwu
        yuwu@c2r4p10:~$ cd ..
        yuwu@c2r4p10:/home$ pwd
        /home
        yuwu@c2r4p10:/home$ pwd
        /home
        yuwu@c2r4p10:/home$ unset PWD
        yuwu@c2r4p10:/home$ pwd
        /home
        yuwu@c2r4p10:/home$ export

=====================Tester Lucas test 83        câš ï¸================================================
Test  83: âš ï¸ echo hi >         ./outfiles/outfile01 bye 
Files ./mini_outfiles/outfile01 and ./bash_outfiles/outfile01 differ
mini outfiles:
bash outfiles:
hi bye
mini output = (hi bye)
bash output = ()
.-------> agreed with lin that its not our problem

=====================how to run minishell in a clean environment ==========================================
env -i ./minishell:                     ignore existing environment
env -i PATH=/usr/bin ./minishell        manually write in with the path

=====================how to run check forbidden functions ==========================================
nm your_program | grep U

âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸
                 U access@GLIBC_2.2.5
                 U add_historyâš ï¸                        ok
                 U chdir@GLIBC_2.2.5âš ï¸                  ok
                 U close@GLIBC_2.2.5
                 U dup2@GLIBC_2.2.5
                 U dup@GLIBC_2.2.5
                 U __errno_location@GLIBC_2.2.5âš ï¸       ??
                 U execve@GLIBC_2.2.5
                 U exit@GLIBC_2.2.5âš ï¸                   ok
                 U fork@GLIBC_2.2.5
                 U fprintf@GLIBC_2.2.5âš ï¸                ok
                 U free@GLIBC_2.2.5
                 U getcwd@GLIBC_2.2.5âš ï¸                 ok
0000000000409400 r __GNU_EH_FRAME_HDR
                 U __libc_start_main@GLIBC_2.34
                 U malloc@GLIBC_2.2.5
                 U open@GLIBC_2.2.5
                 U perror@GLIBC_2.2.5
                 U pipe@GLIBC_2.2.5
                 U printf@GLIBC_2.2.5
                 U readline
                 U rl_clear_history
                 U rl_on_new_line
                 U rl_redisplay
                 U rl_replace_line
                 U signal@GLIBC_2.2.5
                 U stat@GLIBC_2.33 âš ï¸                       ok
                 U unlink@GLIBC_2.2.5âš ï¸                     ok
                 U waitpid@GLIBC_2.2.5
                 U write@GLIBC_2.2.5âš ï¸                      ok

External functs.
readline, rl_clear_history, rl_on_new_line,
rl_replace_line, rl_redisplay, add_history,
printf, malloc, free, write, access, open, read,
close, fork, wait, waitpid, wait3, wait4, signal,
sigaction, sigemptyset, sigaddset, kill, exit,
getcwd, chdir, stat, lstat, fstat, unlink, execve,
dup, dup2, pipe, opendir, readdir, closedir,
strerror, perror, isatty, ttyname, ttyslot, ioctl,
getenv, tcsetattr, tcgetattr, tgetent, tgetflag,
tgetnum, tgetstr, tgoto, tputs

# include "../libft/libft.h"
# include <unistd.h>         	//access, close, fork, dup, dup2, execve, getcwd, pipe
# include <stdlib.h>         	//malloc, free, exit
# include <fcntl.h>				//open 
# include <stdio.h>             //perror
# include <signal.h>			//signal, kill
# include <sys/types.h>			// pid_t, fork, waitpid
# include <readline/readline.h>	//readline  
# include <readline/history.h>	//readline  
# include <sys/wait.h>			//wait, waitpid
# include <errno.h>				//perror
# include <sys/stat.h>			// stat()

=======================================About signal adn exec error in child===============
ï¼ˆå¯é€‰ä½†æ¨èï¼‰ï¼šå­è¿›ç¨‹å‡ºé”™æ—¶æ˜¯å¦ç”¨ errnoï¼Ÿ
ä½ ç›®å‰åœ¨ execve å¤±è´¥æ—¶ï¼š
perror("execve");
exit(127);

è¿™æ˜¯åˆç†çš„ï¼Œå› ä¸ºï¼š

    127 æ˜¯æ ‡å‡† Unix è§„å®šçš„ â€œcommand not found or not executableâ€ è¿”å›å€¼ã€‚

    ç”¨ errno æ›´å¤æ‚ï¼Œåªé€‚åˆä½ è¦åˆ†ç±»å¤„ç†é”™è¯¯åŸå› çš„æƒ…å†µï¼Œå¦åˆ™æ²¡å¿…è¦ã€‚


âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸
ä¸ºä»€ä¹ˆ malloc æˆ– fork å¤±è´¥è¦ç”¨çŠ¶æ€ç  1

çŠ¶æ€ç  1 æ˜¯ POSIX å®šä¹‰çš„â€œæ™®é€šé”™è¯¯ï¼ˆgeneral errorï¼‰â€ï¼Œè¡¨ç¤ºå‘½ä»¤æ‰§è¡Œå¤±è´¥æˆ–ç³»ç»Ÿè°ƒç”¨å¤±è´¥ã€‚

Bash è¡Œä¸ºå¯¹é½è§„åˆ™ï¼š

1 â†’ å‘½ä»¤æ‰§è¡Œå¤±è´¥ã€ç³»ç»Ÿè°ƒç”¨å¤±è´¥ï¼ˆå¦‚ forkã€pipeã€dupã€mallocï¼‰

2 â†’ è¯­æ³•é”™è¯¯æˆ–å†…ç½®å‘½ä»¤ä½¿ç”¨é”™è¯¯

126 â†’ å‘½ä»¤å­˜åœ¨ä½†ä¸å¯æ‰§è¡Œï¼ˆæƒé™é—®é¢˜æˆ–æ˜¯ç›®å½•ï¼‰

127 â†’ å‘½ä»¤ä¸å­˜åœ¨

128 + N â†’ è¢«ä¿¡å· N ç»ˆæ­¢ï¼ˆCtrl-C æ˜¯ 130ï¼‰

æ‰€ä»¥ malloc/fork/pipe/dup å‡ºé”™æ—¶ï¼Œä½ è®¾ç½® $? = 1 æ˜¯ç¬¦åˆ Bash è¡Œä¸ºçš„ã€‚

âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸
å‡ºé”™ç±»å‹	                                            Bash è¡Œä¸º	            Minishell å®ç°
shell å†…éƒ¨ mallocï¼ˆenv_list, exec_cmd->envpï¼‰å¤±è´¥	    fatal	                exit(EXIT_FAILURE)
å‘½ä»¤ malloc/fork/pipe/dup å‡ºé”™	                        $? = 1ï¼Œç»§ç»­æç¤ºç¬¦	     è®¾ç½® exec_cmd->exit_status = 1ï¼Œè¿”å›æç¤ºç¬¦
è¯­æ³•é”™è¯¯	                                            $? = 2	               exec_cmd->exit_status = 2ï¼Œè¿”å›æç¤ºç¬¦
Ctrl-C ä¸­æ–­	                                           $? = 130	               exec_cmd->exit_status = 130ï¼Œè¿”å›æç¤ºç¬¦
å‘½ä»¤ä¸å¯æ‰§è¡Œ	                                        $? = 126	            ä½¿ç”¨ error_126()
å‘½ä»¤ä¸å­˜åœ¨	                                            $? = 127	            ä½¿ç”¨ error_127()
âœ… 


ğŸ“Š heredoc è¡Œä¸ºå¯¹ç…§è¡¨
å†™æ³•	                     delimiter æœ€ç»ˆå€¼	            è¾“å…¥å†…å®¹æ˜¯å¦å±•å¼€å˜é‡	    ç»“æŸæ¡ä»¶ (delimiter åŒ¹é…)
cat << EOF	                EOFï¼ˆä¸å±•å¼€ï¼‰	                 âœ… å±•å¼€ $VAR	        è¾“å…¥è¡Œç­‰äº EOF æ—¶ç»“æŸ
cat << $USER	            å±•å¼€ä¸€æ¬¡ â†’ yuwu	                 âœ… å±•å¼€ $VAR	        è¾“å…¥è¡Œç­‰äº yuwu æ—¶ç»“æŸ
cat << "EOF"	            "EOF"ï¼ˆå»æ‰å¼•å·åæ˜¯ EOFï¼‰	       âŒ ä¸å±•å¼€ $VAR	        è¾“å…¥è¡Œç­‰äº EOF æ—¶ç»“æŸ
cat << '$USER'	            "$USER"ï¼ˆå»æ‰å¼•å·åæ˜¯ $USERï¼‰	   âŒ ä¸å±•å¼€ $VAR	        è¾“å…¥è¡Œç­‰äº $USER æ—¶ç»“æŸ
cat << "$USER"	            å±•å¼€ä¸€æ¬¡ â†’ yuwu	                    âŒ ä¸å±•å¼€ $VAR	     è¾“å…¥è¡Œç­‰äº yuwu æ—¶ç»“æŸ



//used in main
int	handle_token_build_failure(t_exec_path *exec_cmd, t_env **env_list)
{
	ft_free_arr(exec_cmd->envp);
	if (exec_cmd->exit_status == 2 || exec_cmd->exit_status == 0)
		return (0);
	free_env_list(*env_list);
	ft_putstr_fd("Error: get token list failed from memory failure\n", 2);
	//exit(EXIT_FAILURE);
	return (0);
}

volatile sig_atomic_t	g_signal = 0;

static int	run_command(t_exec_path *exec_cmd, t_env **env_list)
{
	t_cmd	*tmp;

	tmp = exec_cmd->whole_cmd;
	while (tmp)
	{
		if (!tmp->argv || !tmp->argv[0])
			tmp->cmd_path = NULL;
		else if (!is_builtin(tmp->argv[0]))
		{
			tmp->cmd_path = get_cmd_path(tmp->argv[0], *env_list, exec_cmd);
			if (exec_cmd->exit_status == 1)
				return (free_t_exec_path(exec_cmd), 0);
		}
		else
			tmp->cmd_path = NULL;
		tmp = tmp->next;
	}
	if (!exec_cmd->whole_cmd->next)
	{
		if (exec_cmd->whole_cmd->argv && is_builtin(exec_cmd->whole_cmd->argv[0]))
			run_builtin_with_redir(exec_cmd, env_list);
		else
			execute_single_cmd(exec_cmd);
	}
	else
		execute_pipeline(exec_cmd, *env_list);
	if (exec_cmd->exit_status == 1)
		return (free_t_exec_path(exec_cmd), 0);
	return (1);
}

// lexing, parsing, and post-expandh eredoc_delim
static int	parse_and_expand(t_exec_path *exec_cmd, char *expanded_line, t_env **env_list)
{
	t_token	*token_list;

	token_list = get_token_list(exec_cmd, expanded_line);
	free(expanded_line);
	if (!token_list)
	{
		// if (!handle_token_build_failure(exec_cmd, env_list))
		// 	return (0);
		return handle_token_build_failure(exec_cmd, env_list);
	}
	exec_cmd->whole_cmd = build_command_list(exec_cmd, token_list);
	free_token_list(token_list);
	if (!exec_cmd->whole_cmd)
	{
		ft_free_arr(exec_cmd->envp);
		if (exec_cmd->exit_status == 2 || exec_cmd->exit_status == 130)
			return (0);
		free_env_list(*env_list);
		ft_putstr_fd("Error: build command list failed from memory failure\n", 2);
		//exit(EXIT_FAILURE);
		return (0); 
	}
	expand_heredoc_delim(exec_cmd, exec_cmd->whole_cmd, exec_cmd->envp);
	return (1);
}

// initiate envp, pre-expand line, lexing, "parse_and_expand", finally run cmd
static void	handle_line(char *line, t_env **env_list, t_exec_path *exec_cmd)
{
	char	*expanded_line;

	exec_cmd->envp = env_list_to_envp(*env_list);
	if (!exec_cmd->envp)
	{
		free(line);
		free_env_list(*env_list);
		ft_putstr_fd("Error: env list initialized failed\n", 2);
		//exit(EXIT_FAILURE);
		exec_cmd->exit_status = 1;
		return ;
	}
	expanded_line = pre_expand_line(exec_cmd, line);
	free(line);
	if (!expanded_line)
	{
		ft_free_arr(exec_cmd->envp);
		free_env_list(*env_list);
		ft_putstr_fd("Error: pre expanding failure\n", 2);
		//exit(EXIT_FAILURE);
		exec_cmd->exit_status = 1;
		return ;
	}
	if (!parse_and_expand(exec_cmd, expanded_line, env_list))
		return ;
	if (!run_command(exec_cmd, env_list))
		return ;
	free_t_exec_path(exec_cmd);
}

//read line, execute cmd loop of minishell
//static void	minishell_loop(t_env *env_list)
static int minishell_loop(t_env *env_list) //yuxin added
{
	t_exec_path	exec_cmd;
	char		*line;

	ft_memset(&exec_cmd, 0, sizeof(exec_cmd));
	while (1)
	{
		line = readline("minishell$ ");
		if (!line)
		{
			printf("exit\n");
			break ;
		}
		if (*line)
		{
			add_history(line);
			handle_line(line, &env_list, &exec_cmd);
		}
	}
	rl_clear_history();
	free_env_list(env_list);
	return (exec_cmd.exit_status); //yuxin added
}

//initiate env and enter cmd loop
int	main(int argc, char **argv, char **envp)
{
	t_env	*env_list;

	(void)argc;
	(void)argv;
	rl_catch_signals = 0;
	signal_init();
	env_list = env_list_init(envp);
	if (!env_list)
	{
		ft_putstr_fd("Error: env list initialized failed\n", 2);
		exit(EXIT_FAILURE);
	}
	// minishell_loop(env_list);
	// return (0);
	return (minishell_loop(env_list));
}