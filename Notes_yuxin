
=================================git collaborations=====================================================
//how to work in your branch and push to the main
	- git checkout branch-name
	- do changes
	- git add .
	- git commit -m "changes"
	- git push origin branch_name
----------------------------------------
	- git checkout main
	- git pull origin main
	- git merge branch_name
	- git add .
	- git commit -m "changes merge to main"
	- git push origin main


=================================minishell workflows=====================================================
main.c         --->  +---------------------------------------------+
ðŸ‘¤ðŸ‘¤ Shared          | init env from envp                          | -> void init_env(char **envp);
                     | init signal handlers                        | -> void setup_signals(void);
                     | shell loop:                                 |
                     |   - readline prompt                         | -> char *read_input(void);
                     |   - pass line to parser                     | -> t_cmd *parse_line(char *line);
                     |   - execute command list                    | -> void execute_commands(t_cmd *cmds, t_env *env);
                     |   - clean up & wait                         | -> void cleanup_shell(t_cmd *cmds);
                     | exit: free everything                       | -> void free_everything(t_cmd *cmds, t_env *env);
                     +---------------------------------------------+
                                        |
                                        v
lexer.c        --->  +---------------------------------------------
ðŸ‘¤ A                 | split line into tokens                      | -> t_token *get_tokens(char *line);
                     | handle quotes, escapes                      | -> char *extract_quoted(char *line, int *i);
                     | classify token types                        | -> t_token_type get_token_type(const char *str);
                     | return token list                           | (same as get_tokens)
                     +---------------------------------------------+
                                        |
                                        v
parser.c       --->  +---------------------------------------------+
ðŸ‘¤ A                 | syntax check (pipes, etc.)                  | -> int check_syntax(t_token *tokens);
                     | build command structures                    | -> t_cmd *build_command_list(t_token *tokens);
                     | handle redirections                         | -> void parse_redirections(t_cmd *cmd, t_token **tokens);
                     | group commands by pipe                      | -> t_cmd *group_by_pipes(t_token *tokens);
                     | return exec-ready tree                      | (same as build_command_list)
                     +---------------------------------------------+
                                        |
                                        v
expander.c    --->   +---------------------------------------------+
ðŸ‘¤ A                 | expand $VARIABLEs                           | -> char *expand_variables(char *str, t_env *env);
                     | handle $? and special vars                  | -> char *expand_special_vars(char *str, int last_exit);
                     | apply quote rules                           | -> char *remove_quotes(char *str);
                     +---------------------------------------------+
                                        |
                                        v
executor.c    --->   +---------------------------------------------+           ------------------------------------------------------->B's work starts to late if A's parsing is not done.
ðŸ‘¤ B                 | for each command:                           |                                                               --->manully make ready token(mock fake token) to B so B can start
                     |   - fork child                              | -> pid_t fork_and_execute(t_cmd *cmd, t_env *env);
                     |   - set up redirs & pipes                   | -> void setup_redirections(t_cmd *cmd);
                     |   - execve or builtin call                  | -> int execute_builtin_or_exec(t_cmd *cmd, t_env *env);
                     | parent: wait for children                   | -> int wait_for_children(void);
                     +---------------------------------------------+
                                        |
        ----------------------+----------------------
        |                                              |
builtins.c    --->  +-------------------------------+     env.c --->  +--------------------------------+
ðŸ‘¤ B                | cd, echo, pwd, etc            |  ðŸ‘¤ B                | env list init & update          |
                    |                               |                 | -> t_env *init_env_list(char **envp);
                    | -> int builtin_cd(char **args, t_env *env); |   | -> void update_env(t_env **env, const char *key, const char *val);
                    | -> int builtin_echo(char **args);           |   | export/unset logic             |
                    | -> int builtin_pwd(void);                   |   | -> int builtin_export(char **args, t_env **env);
                    | exit (in parent)                            |   | -> int builtin_unset(char **args, t_env **env);
                    | -> int builtin_exit(char **args);           |   | -> char **env_to_envp_array(t_env *env);
                    +-------------------------------+             +--------------------------------+
                                        |
                                        v
signals.c     --->   +---------------------------------------------+
ðŸ‘¤ðŸ‘¤ Shared          | SIGINT: handle Ctrl+C                       | -> void sigint_handler(int signo);
                     | SIGQUIT: ignore or handle                   | -> void sigquit_handler(int signo);
                     | restore terminal state                      | -> void restore_terminal_settings(void);
                     +---------------------------------------------+
                                        |
                                        v
utils.c       --->   +---------------------------------------------+
ðŸ‘¤ðŸ‘¤ Shared                      | error printing                  | -> void print_error(const char *msg);
                     | memory management helpers                   | -> void *safe_malloc(size_t size);
                     | free token/cmd/env structs                  | -> void free_tokens(t_token *head);
                     |                                             | -> void free_commands(t_cmd *cmds);
                     |                                             | -> void free_env(t_env *env);
                     +---------------------------------------------+


** Error exit codes:
    - Syntax error:         exit 2
    - Command not found:    exit 127
    - Permission denied:    exit 126
    - Signal exit (e.g. ^C): appropriate status
    - Builtin exit:         user-defined exit code

================================= a fake pipe t_token =====================================================
t_token *create_pipe_test_tokens(void)
{
    t_token *t1 = malloc(sizeof(t_token));
    t_token *t2 = malloc(sizeof(t_token));
    t_token *t3 = malloc(sizeof(t_token));
    t_token *t4 = malloc(sizeof(t_token));
    t_token *t5 = malloc(sizeof(t_token));

    t1->value = strdup("echo");
    t1->type = TOKEN_WORD;
    t1->next = t2;

    t2->value = strdup("hello");
    t2->type = TOKEN_WORD;
    t2->next = t3;

    t3->value = strdup("|");
    t3->type = TOKEN_PIPE;
    t3->next = t4;

    t4->value = strdup("grep");
    t4->type = TOKEN_WORD;
    t4->next = t5;

    t5->value = strdup("h");
    t5->type = TOKEN_WORD;
    t5->next = NULL;

    return t1;
}

=================================concept in parsing=====================================================

prompt: A prompt in a shell is the text displayed to the user that signals it's ready to receive input.
for example:        -bash       user@hostname:~$ 
                    -minishell  minishell$ 

lexing and token
lexing  - a process the analyse the raw line and change it to tokens
token   - the results of the smallest unit

"  " and '   '
'single quotes'     literally just a string
"double quotes"     possibly multiple variables and commands included

=================================other stuff =====================================================