
====================================================================git collaborations=========================================================================
//how to work in your branch and push to the main
	- git checkout branch-name
	- do changes
	- git add .
	- git commit -m "changes"
	- git push origin branch_name
----------------------------------------
	- git checkout main
	- git pull origin main
	- git merge branch_name
	- git add .
	- git commit -m "changes merge to main"
	- git push origin main


===========================================================minishell workflows=========================================================================
main.c         --->  +---------------------------------------------+
ğŸ‘¤ğŸ‘¤ Shared          | init env from envp                          | -> void init_env(char **envp);
                     | init signal handlers                        | -> void setup_signals(void);
                     | shell loop:                                 |
                     |   - readline prompt                         | -> char *read_input(void);
                     |   - pass line to parser                     | -> t_cmd *parse_line(char *line);
                     |   - execute command list                    | -> void execute_commands(t_cmd *cmds, t_env *env);
                     |   - clean up & wait                         | -> void cleanup_shell(t_cmd *cmds);
                     | exit: free everything                       | -> void free_everything(t_cmd *cmds, t_env *env);
                     +---------------------------------------------+
                                        |
                                        v
lexer.c        --->  +---------------------------------------------
ğŸ‘¤ A                 | split line into tokens                      | -> t_token *get_tokens(char *line);
                     | handle quotes, escapes                      | -> char *extract_quoted(char *line, int *i);
                     | classify token types                        | -> t_token_type get_token_type(const char *str);
                     | return token list                           | (same as get_tokens)
                     +---------------------------------------------+
                                        |
                                        v
parser.c       --->  +---------------------------------------------+
ğŸ‘¤ A                 | syntax check (pipes, etc.)                  | -> int check_syntax(t_token *tokens);
                     | build command structures                    | -> t_cmd *build_command_list(t_token *tokens);
                     | handle redirections                         | -> void parse_redirections(t_cmd *cmd, t_token **tokens);
                     | group commands by pipe                      | -> t_cmd *group_by_pipes(t_token *tokens);
                     | return exec-ready tree                      | (same as build_command_list)
                     +---------------------------------------------+
                                        |
                                        v
expander.c    --->   +---------------------------------------------+
ğŸ‘¤ A                 | expand $VARIABLEs                           | -> char *expand_variables(char *str, t_env *env);
                     | handle $? and special vars                  | -> char *expand_special_vars(char *str, int last_exit);
                     | apply quote rules                           | -> char *remove_quotes(char *str);
                     +---------------------------------------------+
                                        |
                                        v
executor.c    --->   +---------------------------------------------+
ğŸ‘¤ B                 | for each command:                           |
                     |   - fork child                              | -> pid_t fork_and_execute(t_cmd *cmd, t_env *env);
                     |   - set up redirs & pipes                   | -> void setup_redirections(t_cmd *cmd);
                     |   - execve or builtin call                  | -> int execute_builtin_or_exec(t_cmd *cmd, t_env *env);
                     | parent: wait for children                   | -> int wait_for_children(void);
                     +---------------------------------------------+
                                        |
        ----------------------+----------------------
        |                                              |
builtins.c    --->  +-------------------------------+     env.c --->  +--------------------------------+
ğŸ‘¤ B                | cd, echo, pwd, etc            |  ğŸ‘¤ B                | env list init & update          |
                    |                               |                 | -> t_env *init_env_list(char **envp);
                    | -> int builtin_cd(char **args, t_env *env); |   | -> void update_env(t_env **env, const char *key, const char *val);
                    | -> int builtin_echo(char **args);           |   | export/unset logic             |
                    | -> int builtin_pwd(void);                   |   | -> int builtin_export(char **args, t_env **env);
                    | exit (in parent)                            |   | -> int builtin_unset(char **args, t_env **env);
                    | -> int builtin_exit(char **args);           |   | -> char **env_to_envp_array(t_env *env);
                    +-------------------------------+             +--------------------------------+
                                        |
                                        v
signals.c     --->   +---------------------------------------------+
ğŸ‘¤ğŸ‘¤ Shared          | SIGINT: handle Ctrl+C                       | -> void sigint_handler(int signo);
                     | SIGQUIT: ignore or handle                   | -> void sigquit_handler(int signo);
                     | restore terminal state                      | -> void restore_terminal_settings(void);
                     +---------------------------------------------+
                                        |
                                        v
utils.c       --->   +---------------------------------------------+
ğŸ‘¤ğŸ‘¤ Shared                      | error printing                  | -> void print_error(const char *msg);
                     | memory management helpers                   | -> void *safe_malloc(size_t size);
                     | free token/cmd/env structs                  | -> void free_tokens(t_token *head);
                     |                                             | -> void free_commands(t_cmd *cmds);
                     |                                             | -> void free_env(t_env *env);
                     +---------------------------------------------+


** Error exit codes:

    - Syntax error:             exit 2
    - Command not found:        exit 127
    - Permission denied:        exit 126
    - Signal exit (e.g. ^C):    appropriate status: like 128 + status
    - Builtin exit:             user-defined exit code

==============================================================concept in parsing==================================================================================

-------> prompt: A prompt in a shell is the text displayed to the user that signals it's ready to receive input.
for example:        -bash       user@hostname:~$
                    -minishell  minishell$

-------> lexing and token
lexing  - a process the analyse the raw line and change it to tokens
token   - the results of the smallest unit

-------> "  " and '   '
        'single quotes'     literally just a string
        "double quotes"     possibly multiple variables and commands included

-------> Error msg in different phase  
Phase	        Checks file existence?	          Errors?
Lexing	        No	                              Only special character and unclosed quotes
Parsing	        No	                              Only invalid structure
Execution	    Yes	                              File not found, command not found, etc.

========================================================continous redirections should be allowd ===========================================================
----->  example case
    ->  echo > out1 > out2 > out3
    ->  cat < in1 < in2 < in3
    ->  cat < file1 > file2 < file1: does this make sense: should we handle it?
    ->  cat < in.txt > out.txtThis reads from in.txt and writes to out.txt.
    ->  grep hello < file.txt > result.txt, grep hello from infile and put it to a outfile

----->  to handles this, we have redirection node as a linked list
typedef struct s_redir {
	char *file;
	int type; // T_REDIRECT_IN, T_REDIRECT_OUT, T_APPEND, T_HEREDOC
	struct s_redir *next;
} t_redir;

typedef struct s_cmd
{
	char **argv;
	t_redir *redirections;  // <-- list of redirections
	struct s_cmd *next;
} t_cmd;

-----> more infor about bash behaviors of continous refirection
    - In real Bash, even though only the last redirection affects where the command reads/writes
    - all redirections are processed in order, and errors can occur during any redirection (not just the last).
    - in one cmd, redirectin, redirectout, append and heredoc can appear at the same time for multiple times


=================================================================PARSEING for example=================================================================
echo "hello world" > file.txt | cat -e
[TOKEN: echo]	[TOKEN: "hello world"]	[TOKEN: >]	[TOKEN: file.txt]   [TOKEN: |] 	[TOKEN: cat]  	[TOKEN: -e]
T_WORD	  				T_WORD		T_REDIRECT_OUT		 T_WORD			  T_PIPE	   T_WORD		  T_WORD
--------------------------------------------------------------------------------------
t_cmd *cmd_list = cmd1;
cmd1:
argv:        ["echo", "hello world", NULL]
infile:      NULL
outfile:     "file.txt"
append_out:  0
heredoc_delim: NULL
next:        -> cmd2
-----------------------------------------------
cmd2:
argv:        ["cat", "-e", NULL]
infile:      NULL
outfile:     NULL
append_out:  0
heredoc_delim: NULL
next:        NULL


================================================================PARSEING test case Specail ====================================================
----------------> Prespanding
1. preexpading is needed, for cmd as VAR
    ->  export $CMD="echo hello"
        $CMD
    preexpading is needed, also for VAR can mess up with cmd
    ->  echo$USER           bash: echoyuwu: command not found

----------------> Parsing
1. "<" and '<' should be solid input argv, but < is certainly redirect int
    ->  echo "<"
    ->  echo "<"<<"<"
    ->  echo "<<"<<"<<"
    ->  echo '>>'

2. first redirections and then actuall command is valid in bash    
    -> > out.txt echo hello       
    -> echo hello > out.txt       this one is working
    -> echo > out.txt hello     this one is working

3. about quotes
    ->  echo "hello "yuxin" wi"
        echo 'hello 'yuxin' wi'
        echo "hello 'yuxin' wi"
        echo 'hello "yuxin" wi'

4.  empty string executions 
    ->  minishell$ ""
        Command '' not found,


----------------> Expansion
1. normal expansion case
    ->  minishell$ echo "$USER "$USER" '$USER'" '$USER' "$USER"
        echo "Hello $USER"	                    "Hello alice"
        echo 'Hello $USER'	                    'Hello $USER'
        echo "Path is $PATH/bin"	            "Path is /usr/bin:/bin/bin"
        echo "$"	                            "" (empty string or preserved as literal)
        echo "$UNDEFINED"	                    ""
        echo "Mix$VAR1and$VAR2"	                "Mixval1andval2" 
        echo "yuxin $USER '$USER' "user" kk,"

2. heredoc without quotes should not be expanded 
    ->  minishell$ echo << $USER                    
        > skfd
        > mikko
        > $USER
    ->  minishell$ echo << $SUER                    
        minishell: syntax error: missing filename or delimiter after redirection

3. heredoc with quotes should not be expanded             âŒâŒâŒâŒâŒâŒâŒâŒ
    mikko@mikko-desktop-ubuntu:~/yuxin_home/minishell$ cat << ""$USER
    > asd
    > sdfg
    > mikko
    > $USER
    asd
    sdfg
    mikko
    mikko@mikko-desktop-ubuntu:~/yuxin_home/minishell$ ./minishell 
    minishell$ cat << ""$USER
    minishell heredoc> sdf
    minishell heredoc> mikko
    sdf

5. heredoc with quotes should not be expanded             âŒâŒâŒâŒâŒâŒâŒâŒ same as above
    yuwu@c2r6p13:~$ echo << $ABC"" | grep abc
    > $USER
    > abc sdfkljsdfkjl
    > $USER"abc"
    > fgjkfgjk
    > fgkljfghklj
    > abcok
    > $ABC
    yuwu@c2r6p13:~$ cat << $ABC"" | grep abc
    $USER
    abc sdfkljsdfkjl
    $USER"abc"
    fgjkfgjk
    fgkljfghklj
    abcok
    $ABC
    abc sdfkljsdfkjl
    $USER"abc"
    abcok
    yuwu@c2r6p13:~$ cat << $ABC"" | grep abc
    > $ABC abc
    > dfgjkdflgj
    > dflgkjjdfgkj
    > abcok
    > $USER abc
    > fdgkjdg
    > abcok
    > $ABC
    $ABC abc
    abcok
    $USER abc
    abcok
    yuwu@c2r6p13:~$ cat << $ABC | grep abc
    > $USER abc
    > $USER
    > abcok
    > dfgjklfdgjkl
    > $ABC
    yuwu abc
    abcok
4. multiple $, or ""
    mikko@mikko-desktop-ubuntu:~/yuxin_home/minishell$ echo $
    $
    mikko@mikko-desktop-ubuntu:~/yuxin_home/minishell$ echo "$"$
    $$
    mikko@mikko-desktop-ubuntu:~/yuxin_home/minishell$ echo "$"$"$"
    $$
    mikko@mikko-desktop-ubuntu:~/yuxin_home/minishell$ echo "$" $ "$"
    $ $ $
    mikko@mikko-desktop-ubuntu:~/yuxin_home/minishell$ echo "$"$ "$"
    $$ $
    mikko@mikko-desktop-ubuntu:~/yuxin_home/minishell$ echo "$"$$"$" âš ï¸
    $217485$
    mikko@mikko-desktop-ubuntu:~/yuxin_home/minishell$ echo $? $$ âš ï¸
    0 217485
    mikko@mikko-desktop-ubuntu:~/yuxin_home/minishell$ echo $?$$ âš ï¸
    0217485
    mikko@mikko-desktop-ubuntu:~/yuxin_home/minishell$ echo $?$?"$"$?"$" âš ï¸
    00$0$
    mikko@mikko-desktop-ubuntu:~/yuxin_home/minishell$ echo $?$?"$"$?$"$" âš ï¸
    00$0$

5. first export our own VAR, and then echo $VAR, with / without -n, with / without quotes
    yuwu@c2r6p13:~/42/Rank3_minishell$ export A="     a       b     "
    yuwu@c2r6p13:~/42/Rank3_minishell$ echo $A
    a b
    yuwu@c2r6p13:~/42/Rank3_minishell$ echo -n $A
    a b
    yuwu@c2r6p13:~/42/Rank3_minishell$ echo -n "$A"
        a       b     
    yuwu@c2r6p13:~/42/Rank3_minishell$ echo "$A"
        a       b     

----------------> Syntax
1. a cmd can have null as argv, just redirection
    ->  cat Makefile | < in
    ->  < in

----------------> build in
1. cd
    ->  cd without argv[1] means change home
2. exit
    yuwu@c2r4p10:~$ exit 1 1
    exit
    bash: exit: too many arguments
    yuwu@c2r4p10:~$ exit a 1
    exit
    bash: exit: a: numeric argument required
    c2r4p10% bash
    yuwu@c2r4p10:~$ exit 1
    exit
    c2r4p10% bash
    yuwu@c2r4p10:~$ exit 1111111111111111111111111111111
    exit
    bash: exit: 1111111111111111111111111111111: numeric argument required
    c2r4p10% bash    
    yuwu@c2r4p10:~$ exit 300
    exit
    c2r4p10% echo  $?
    44
    c2r4p10% 300-256
    zsh: command not found: 300-256
3. export
    ->  export has to have valid varaiable name
        ->   export 77="1 2 3"
4. echo
    -> -n or not -n
        yuwu@c2r4p10:~$ echo -nnnnnnn 123
        123yuwu@c2r4p10:~$ echo -nnnnnnn -nnnnn -n -nnnn 123
        123yuwu@c2r4p10:~$ echo -nnnnnnn -nnnnn -n -nnnn -n-n 123
        -n-n 123yuwu@c2r4p10:~$ pwd
        /home/yuwu
        yuwu@c2r4p10:~$ cd ..
        yuwu@c2r4p10:/home$ pwd
        /home
        yuwu@c2r4p10:/home$ pwd
        /home
        yuwu@c2r4p10:/home$ unset PWD
        yuwu@c2r4p10:/home$ pwd
        /home
        yuwu@c2r4p10:/home$ export

=====================Tester Lucas test 83        âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸================================================
Test  83: âš ï¸ echo hi >         ./outfiles/outfile01 bye 
Files ./mini_outfiles/outfile01 and ./bash_outfiles/outfile01 differ
mini outfiles:
bash outfiles:
hi bye
mini output = (hi bye)
bash output = ()
.-------> agreed with lin that its not our problem


====================================later to check forbiddent functions and header file =============================
// External functs allowed .
// readline            - get a line from a user with editing       get a line from a user with editing
// rl_clear_history    ??
// rl_on_new_line      ??
// rl_replace_line     ??
// rl_redisplay        ??
// add_history         ??
// printf              ??
// malloc, free
// write               ??
// access             -check user's permissions for a file
// open                ??
// read                ??
// close               - close a file descriptor                  int close(int fd);
// fork                -  create a child proces                   pid_t fork(void);
// wait, waitpid, wait3, wait4                                     ??
// signal              - ANSI C signal handling                    sighandler_t signal(int signum, sighandler_t handler);
// sigaction           - examine and change a signal action
// sigemptyset         ??
// sigaddset           - POSIX signal set operations
// kill                 - send a signal to a processq
// exit,                â€” cause the shell to exit              exit [n]
// getcwd, chdir, stat, lstat, fstat, unlink, execve,
// dup, dup2, pipe, opendir, readdir, closedir,
// strerror, perror, isatty, ttyname, ttyslot, ioctl,
// getenv, tcsetattr, tcgetattr, tgetent, tgetflag,
// tgetnum, tgetstr, tgoto, tputs

// #include <unistd.h>         //access, access, close, fork
// #include <stdlib.h>         //malloc, free
// #include <fcntl.h
> $USER
ksdjf
>
// #include <stdio.h>  //readline, printf
// #include <string.h>
// # include <errno.h>
// sigaddset
// #include <signal.h>         //signal, sigaction,
// # include <sys/wait.h>

=======================================About signal adn exec error in child===============
ï¼ˆå¯é€‰ä½†æ¨èï¼‰ï¼šå­è¿›ç¨‹å‡ºé”™æ—¶æ˜¯å¦ç”¨ errnoï¼Ÿ
ä½ ç›®å‰åœ¨ execve å¤±è´¥æ—¶ï¼š
perror("execve");
exit(127);

è¿™æ˜¯åˆç†çš„ï¼Œå› ä¸ºï¼š

    127 æ˜¯æ ‡å‡† Unix è§„å®šçš„ â€œcommand not found or not executableâ€ è¿”å›å€¼ã€‚

    ç”¨ errno æ›´å¤æ‚ï¼Œåªé€‚åˆä½ è¦åˆ†ç±»å¤„ç†é”™è¯¯åŸå› çš„æƒ…å†µï¼Œå¦åˆ™æ²¡å¿…è¦ã€‚