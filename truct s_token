[4mmalloc[24m(3)                      Library Functions Manual                      [4mmalloc[24m(3)

[1mNAME[0m
       malloc, free, calloc, realloc, reallocarray - allocate and free dynamic memory

[1mLIBRARY[0m
       Standard C library ([4mlibc[24m, [4m-lc[24m)

[1mSYNOPSIS[0m
       [1m#include <stdlib.h>[0m

       [1mvoid *malloc(size_t [4m[22msize[24m[1m);[0m
       [1mvoid free(void *_Nullable [4m[22mptr[24m[1m);[0m
       [1mvoid *calloc(size_t [4m[22mnmemb[24m[1m, size_t [4m[22msize[24m[1m);[0m
       [1mvoid *realloc(void *_Nullable [4m[22mptr[24m[1m, size_t [4m[22msize[24m[1m);[0m
       [1mvoid *reallocarray(void *_Nullable [4m[22mptr[24m[1m, size_t [4m[22mnmemb[24m[1m, size_t [4m[22msize[24m[1m);[0m

   Feature Test Macro Requirements for glibc (see [1mfeature_test_macros[22m(7)):

       [1mreallocarray[22m():
           Since glibc 2.29:
               _DEFAULT_SOURCE
           glibc 2.28 and earlier:
               _GNU_SOURCE

[1mDESCRIPTION[0m
   [1mmalloc()[0m
       The  [1mmalloc[22m()  function allocates [4msize[24m bytes and returns a pointer to the allo‚Äê
       cated memory.  [4mThe[24m [4mmemory[24m [4mis[24m [4mnot[24m [4minitialized[24m.  If [4msize[24m is 0, then [1mmalloc[22m()  re‚Äê
       turns  a  unique pointer value that can later be successfully passed to [1mfree[22m().
       (See "Nonportable behavior" for portability issues.)

   [1mfree()[0m
       The [1mfree[22m() function frees the memory space pointed to by [4mptr[24m, which  must  have
       been  returned by a previous call to [1mmalloc[22m() or related functions.  Otherwise,
       or if [4mptr[24m has already been freed, undefined behavior occurs.  If [4mptr[24m  is  NULL,
       no operation is performed.

   [1mcalloc()[0m
       The  [1mcalloc[22m()  function allocates memory for an array of [4mnmemb[24m elements of [4msize[0m
       bytes each and returns a pointer to the allocated memory.  The memory is set to
       zero.  If [4mnmemb[24m or [4msize[24m is 0, then [1mcalloc[22m() returns a unique pointer value that
       can later be successfully passed to [1mfree[22m().

       If the multiplication of [4mnmemb[24m and [4msize[24m would result in integer overflow,  then
       [1mcalloc[22m()  returns  an error.  By contrast, an integer overflow would not be de‚Äê
       tected in the following call to [1mmalloc[22m(), with the result that  an  incorrectly
       sized block of memory would be allocated:

           malloc(nmemb * size);

   [1mrealloc()[0m
       The  [1mrealloc[22m()  function changes the size of the memory block pointed to by [4mptr[0m
       to [4msize[24m bytes.  The contents of the memory will be unchanged in the range  from
       the start of the region up to the minimum of the old and new sizes.  If the new
       size is larger than the old size, the added memory will [4mnot[24m be initialized.

       If  [4mptr[24m is NULL, then the call is equivalent to [4mmalloc(size)[24m, for all values of
       [4msize[24m.

       If [4msize[24m is equal to zero, and [4mptr[24m is not NULL, then the call is  equivalent  to
       [4mfree(ptr)[24m (but see "Nonportable behavior" for portability issues).

       Unless  [4mptr[24m is NULL, it must have been returned by an earlier call to [1mmalloc [22mor
       related functions.  If the area pointed to was moved, a [4mfree(ptr)[24m is done.

   [1mreallocarray()[0m
       The [1mreallocarray[22m() function changes the size of (and possibly moves) the memory
       block pointed to by [4mptr[24m to be large enough for an array of [4mnmemb[24m elements, each
       of which is [4msize[24m bytes.  It is equivalent to the call

           realloc(ptr, nmemb * size);

       However, unlike that [1mrealloc[22m() call, [1mreallocarray[22m() fails safely  in  the  case
       where  the  multiplication would overflow.  If such an overflow occurs, [1mreallo‚Äê[0m
       [1mcarray[22m() returns an error.

[1mRETURN VALUE[0m
       The [1mmalloc[22m(),  [1mcalloc[22m(),  [1mrealloc[22m(),  and  [1mreallocarray[22m()  functions  return  a
       pointer  to  the  allocated memory, which is suitably aligned for any type that
       fits into the requested size or less.  On error, these  functions  return  NULL
       and  set  [4merrno[24m.  Attempting to allocate more than [1mPTRDIFF_MAX [22mbytes is consid‚Äê
       ered an error, as an object that large could cause later pointer subtraction to
       overflow.

       The [1mfree[22m() function returns no value, and preserves [4merrno[24m.

       The [1mrealloc[22m() and [1mreallocarray[22m() functions return NULL if [4mptr[24m is not  NULL  and
       the requested size is zero; this is not considered an error.  (See "Nonportable
       behavior"  for portability issues.)  Otherwise, the returned pointer may be the
       same as [4mptr[24m if the allocation was not moved (e.g., there was room to expand the
       allocation in-place), or different from [4mptr[24m if the allocation was  moved  to  a
       new address.  If these functions fail, the original block is left untouched; it
       is not freed or moved.

[1mERRORS[0m
       [1mcalloc[22m(),  [1mmalloc[22m(),  [1mrealloc[22m(), and [1mreallocarray[22m() can fail with the following
       error:

       [1mENOMEM [22mOut  of  memory.   Possibly,  the  application  hit  the  [1mRLIMIT_AS   [22mor
              [1mRLIMIT_DATA  [22mlimit  described  in [1mgetrlimit[22m(2).  Another reason could be
              that the number of mappings created by the caller process  exceeded  the
              limit specified by [4m/proc/sys/vm/max_map_count[24m.

[1mATTRIBUTES[0m
       For an explanation of the terms used in this section, see [1mattributes[22m(7).
       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
       ‚îÇ [1mInterface                                         [22m‚îÇ [1mAttribute     [22m‚îÇ [1mValue   [22m‚îÇ
       ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
       ‚îÇ [1mmalloc[22m(), [1mfree[22m(), [1mcalloc[22m(), [1mrealloc[22m()             ‚îÇ Thread safety ‚îÇ MT-Safe ‚îÇ
       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

[1mSTANDARDS[0m
       [1mmalloc[22m()
       [1mfree[22m()
       [1mcalloc[22m()
       [1mrealloc[22m()
              C11, POSIX.1-2008.

       [1mreallocarray[22m()
              None.

[1mHISTORY[0m
       [1mmalloc[22m()
       [1mfree[22m()
       [1mcalloc[22m()
       [1mrealloc[22m()
              POSIX.1-2001, C89.

       [1mreallocarray[22m()
              glibc 2.26.  OpenBSD 5.6, FreeBSD 11.0.

       [1mmalloc[22m() and related functions rejected sizes greater than [1mPTRDIFF_MAX [22mstarting
       in glibc 2.30.

       [1mfree[22m() preserved [4merrno[24m starting in glibc 2.33.

[1mNOTES[0m
       By default, Linux follows an optimistic memory allocation strategy.  This means
       that  when  [1mmalloc[22m() returns non-NULL there is no guarantee that the memory re‚Äê
       ally is available.  In case it turns out that the system is out of memory,  one
       or  more processes will be killed by the OOM killer.  For more information, see
       the description of [4m/proc/sys/vm/overcommit_memory[24m and  [4m/proc/sys/vm/oom_adj[24m  in
       [1mproc[22m(5),  and the Linux kernel source file [4mDocumentation/vm/overcommit-account‚Äê[0m
       [4ming.rst[24m.

       Normally, [1mmalloc[22m() allocates memory from the heap, and adjusts the size of  the
       heap  as required, using [1msbrk[22m(2).  When allocating blocks of memory larger than
       [1mMMAP_THRESHOLD [22mbytes, the glibc [1mmalloc[22m() implementation allocates the memory as
       a private anonymous mapping using [1mmmap[22m(2).  [1mMMAP_THRESHOLD  [22mis  128 kB  by  de‚Äê
       fault, but is adjustable using [1mmallopt[22m(3).  Prior to Linux 4.7 allocations per‚Äê
       formed  using  [1mmmap[22m(2) were unaffected by the [1mRLIMIT_DATA [22mresource limit; since
       Linux 4.7, this limit is also enforced for allocations performed using [1mmmap[22m(2).

       To avoid corruption in multithreaded applications, mutexes are used  internally
       to  protect  the memory-management data structures employed by these functions.
       In a multithreaded application in which  threads  simultaneously  allocate  and
       free  memory,  there could be contention for these mutexes.  To scalably handle
       memory allocation in multithreaded applications, glibc creates additional  [4mmem‚Äê[0m
       [4mory[24m  [4mallocation[24m  [4marenas[24m if mutex contention is detected.  Each arena is a large
       region of memory that is internally allocated by the system  (using  [1mbrk[22m(2)  or
       [1mmmap[22m(2)), and managed with its own mutexes.

       If  your  program uses a private memory allocator, it should do so by replacing
       [1mmalloc[22m(), [1mfree[22m(), [1mcalloc[22m(), and [1mrealloc[22m().  The replacement functions must  im‚Äê
       plement the documented glibc behaviors, including [4merrno[24m handling, size-zero al‚Äê
       locations,  and  overflow checking; otherwise, other library routines may crash
       or operate incorrectly.  For example, if the replacement [4mfree[24m() does  not  pre‚Äê
       serve  [4merrno[24m, then seemingly unrelated library routines may fail without having
       a valid reason in [4merrno[24m.  Private memory allocators may also  need  to  replace
       other glibc functions; see "Replacing malloc" in the glibc manual for details.

       Crashes in memory allocators are almost always related to heap corruption, such
       as overflowing an allocated chunk or freeing the same pointer twice.

       The  [1mmalloc[22m()  implementation  is  tunable  via environment variables; see [1mmal‚Äê[0m
       [1mlopt[22m(3) for details.

   [1mNonportable behavior[0m
       The behavior of these functions when the requested size is zero is  glibc  spe‚Äê
       cific;  other  implementations  may  return  NULL  without  setting  [4merrno[24m, and
       portable POSIX programs should tolerate such behavior.  See [1mrealloc[22m(3p).

       POSIX requires memory allocators to set [4merrno[24m upon  failure.   However,  the  C
       standard  does  not  require this, and applications portable to non-POSIX plat‚Äê
       forms should not assume this.

       Portable programs should not use private memory allocators, as POSIX and the  C
       standard do not allow replacement of [1mmalloc[22m(), [1mfree[22m(), [1mcalloc[22m(), and [1mrealloc[22m().

[1mEXAMPLES[0m
       #include <err.h>
       #include <stddef.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <string.h>

       #define MALLOCARRAY(n, type)  ((type *) my_mallocarray(n, sizeof(type)))
       #define MALLOC(type)          MALLOCARRAY(1, type)

       static inline void *my_mallocarray(size_t nmemb, size_t size);

       int
       main(void)
       {
           char  *p;

           p = MALLOCARRAY(32, char);
           if (p == NULL)
               err(EXIT_FAILURE, "malloc");

           strlcpy(p, "foo", 32);
           puts(p);
       }

       static inline void *
       my_mallocarray(size_t nmemb, size_t size)
       {
           return reallocarray(NULL, nmemb, size);
       }

[1mSEE ALSO[0m
       [1mvalgrind[22m(1), [1mbrk[22m(2), [1mmmap[22m(2), [1malloca[22m(3), [1mmalloc_get_state[22m(3), [1mmalloc_info[22m(3),
       [1mmalloc_trim[22m(3), [1mmalloc_usable_size[22m(3), [1mmallopt[22m(3), [1mmcheck[22m(3), [1mmtrace[22m(3),
       [1mposix_memalign[22m(3)

       For details of the GNU C library implementation, see
       ]8;;https://sourceware.org/glibc/wiki/MallocInternals\https://sourceware.org/glibc/wiki/MallocInternals]8;;\.

Linux man-pages 6.7                   2023-10-31                             [4mmalloc[24m(3)

                   SSUUMMMMAARRYY OOFF LLEESSSS CCOOMMMMAANNDDSS

      Commands marked with * may be preceded by a number, _N.
      Notes in parentheses indicate the behavior if _N is given.
      A key preceded by a caret indicates the Ctrl key; thus ^K is ctrl-K.

  h  H                 Display this help.
  q  :q  Q  :Q  ZZ     Exit.
 ---------------------------------------------------------------------------

                           MMOOVVIINNGG

  e  ^E  j  ^N  CR  *  Forward  one line   (or _N lines).
  y  ^Y  k  ^K  ^P  *  Backward one line   (or _N lines).
  f  ^F  ^V  SPACE  *  Forward  one window (or _N lines).
  b  ^B  ESC-v      *  Backward one window (or _N lines).
  z                 *  Forward  one window (and set window to _N).
  w                 *  Backward one window (and set window to _N).
  ESC-SPACE         *  Forward  one window, but don't stop at end-of-file.
  d  ^D             *  Forward  one half-window (and set half-window to _N).
  u  ^U             *  Backward one half-window (and set half-window to _N).
  ESC-)  RightArrow *  Right one half screen width (or _N positions).
  ESC-(  LeftArrow  *  Left  one half screen width (or _N positions).
  ESC-}  ^RightArrow   Right to last column displayed.
  ESC-{  ^LeftArrow    Left  to first column.
  F                    Forward forever; like "tail -f".
  ESC-F                Like F but stop when search pattern is found.
  r  ^R  ^L            Repaint screen.
  R                    Repaint screen, discarding buffered input.
        ---------------------------------------------------
        Default "window" is the screen height.
        Default "half-window" is half of the screen height.
 ---------------------------------------------------------------------------

                          SSEEAARRCCHHIINNGG

  /_p_a_t_t_e_r_n          *  Search forward for (_N-th) matching line.
  ?_p_a_t_t_e_r_n          *  Search backward for (_N-th) matching line.
  n                 *  Repeat previous search (for _N-th occurrence).
  N                 *  Repeat previous search in reverse direction.
  ESC-n             *  Repeat previous search, spanning files.
  ESC-N             *  Repeat previous search, reverse dir. & spanning files.
  ESC-u                Undo (toggle) search highlighting.
  ESC-U                Clear search highlighting.
  &_p_a_t_t_e_r_n          *  Display only matching lines.
        ---------------------------------------------------
        A search pattern may begin with one or more of:
        ^N or !  Search for NON-matching lines.
        ^E or *  Search multiple files (pass thru END OF FILE).
        ^F or @  Start search at FIRST file (for /) or last file (for ?).
        ^K       Highlight matches, but don't move (KEEP position).
        ^R       Don't use REGULAR EXPRESSIONS.
        ^W       WRAP search if no match found.
 ---------------------------------------------------------------------------

                           JJUUMMPPIINNGG

  g  <  ESC-<       *  Go to first line in file (or line _N).
  G  >  ESC->       *  Go to last line in file (or line _N).
  p  %              *  Go to beginning of file (or _N percent into file).
  t                 *  Go to the (_N-th) next tag.
  T                 *  Go to the (_N-th) previous tag.
  {  (  [           *  Find close bracket } ) ].
  }  )  ]           *  Find open bracket { ( [.
  ESC-^F _<_c_1_> _<_c_2_>  *  Find close bracket _<_c_2_>.
  ESC-^B _<_c_1_> _<_c_2_>  *  Find open bracket _<_c_1_>.
        ---------------------------------------------------
        Each "find close bracket" command goes forward to the close bracket 
          matching the (_N-th) open bracket in the top line.
        Each "find open bracket" command goes backward to the open bracket 
          matching the (_N-th) close bracket in the bottom line.

  m_<_l_e_t_t_e_r_>            Mark the current top line with <letter>.
  M_<_l_e_t_t_e_r_>            Mark the current bottom line with <letter>.
  '_<_l_e_t_t_e_r_>            Go to a previously marked position.
  ''                   Go to the previous position.
  ^X^X                 Same as '.
  ESC-M_<_l_e_t_t_e_r_>        Clear a mark.
        ---------------------------------------------------
        A mark is any upper-case or lower-case letter.
        Certain marks are predefined:
             ^  means  beginning of the file
             $  means  end of the file
 ---------------------------------------------------------------------------

                        CCHHAANNGGIINNGG FFIILLEESS

  :e [_f_i_l_e]            Examine a new file.
  ^X^V                 Same as :e.
  :n                *  Examine the (_N-th) next file from the command line.
  :p                *  Examine the (_N-th) previous file from the command line.
  :x                *  Examine the first (or _N-th) file from the command line.
  :d                   Delete the current file from the command line list.
  =  ^G  :f            Print current file name.
 ---------------------------------------------------------------------------

                    MMIISSCCEELLLLAANNEEOOUUSS CCOOMMMMAANNDDSS

  -_<_f_l_a_g_>              Toggle a command line option [see OPTIONS below].
  --_<_n_a_m_e_>             Toggle a command line option, by name.
  __<_f_l_a_g_>              Display the setting of a command line option.
  ___<_n_a_m_e_>             Display the setting of an option, by name.
  +_c_m_d                 Execute the less cmd each time a new file is examined.

  !_c_o_m_m_a_n_d             Execute the shell command with $SHELL.
  |XX_c_o_m_m_a_n_d            Pipe file between current pos & mark XX to shell command.
  s _f_i_l_e               Save input to a file.
  v                    Edit the current file with $VISUAL or $EDITOR.
  V                    Print version number of "less".
 ---------------------------------------------------------------------------

                           OOPPTTIIOONNSS

        Most options may be changed either on the command line,
        or from within less by using the - or -- command.
        Options may be given in one of two forms: either a single
        character preceded by a -, or a name preceded by --.

  -?  ........  --help
                  Display help (from command line).
  -a  ........  --search-skip-screen
                  Search skips current screen.
  -A  ........  --SEARCH-SKIP-SCREEN
                  Search starts just after target line.
  -b [_N]  ....  --buffers=[_N]
                  Number of buffers.
  -B  ........  --auto-buffers
                  Don't automatically allocate buffers for pipes.
  -c  ........  --clear-screen
                  Repaint by clearing rather than scrolling.
  -d  ........  --dumb
                  Dumb terminal.
  -D xx_c_o_l_o_r  .  --color=xx_c_o_l_o_r
                  Set screen colors.
  -e  -E  ....  --quit-at-eof  --QUIT-AT-EOF
                  Quit at end of file.
  -f  ........  --force
                  Force open non-regular files.
  -F  ........  --quit-if-one-screen
                  Quit if entire file fits on first screen.
  -g  ........  --hilite-search
                  Highlight only last match for searches.
  -G  ........  --HILITE-SEARCH
                  Don't highlight any matches for searches.
  -h [_N]  ....  --max-back-scroll=[_N]
                  Backward scroll limit.
  -i  ........  --ignore-case
                  Ignore case in searches that do not contain uppercase.
  -I  ........  --IGNORE-CASE
                  Ignore case in all searches.
  -j [_N]  ....  --jump-target=[_N]
                  Screen position of target lines.
  -J  ........  --status-column
                  Display a status column at left edge of screen.
  -k [_f_i_l_e]  .  --lesskey-file=[_f_i_l_e]
                  Use a lesskey file.
  -K  ........  --quit-on-intr
                  Exit less in response to ctrl-C.
  -L  ........  --no-lessopen
                  Ignore the LESSOPEN environment variable.
  -m  -M  ....  --long-prompt  --LONG-PROMPT
                  Set prompt style.
  -n  -N  ....  --line-numbers  --LINE-NUMBERS
                  Don't use line numbers.
  -o [_f_i_l_e]  .  --log-file=[_f_i_l_e]
                  Copy to log file (standard input only).
  -O [_f_i_l_e]  .  --LOG-FILE=[_f_i_l_e]
                  Copy to log file (unconditionally overwrite).
  -p [_p_a_t_t_e_r_n]  --pattern=[_p_a_t_t_e_r_n]
                  Start at pattern (from command line).
  -P [_p_r_o_m_p_t]   --prompt=[_p_r_o_m_p_t]
                  Define new prompt.
  -q  -Q  ....  --quiet  --QUIET  --silent --SILENT
                  Quiet the terminal bell.
  -r  -R  ....  --raw-control-chars  --RAW-CONTROL-CHARS
                  Output "raw" control characters.
  -s  ........  --squeeze-blank-lines
                  Squeeze multiple blank lines.
  -S  ........  --chop-long-lines
                  Chop (truncate) long lines rather than wrapping.
  -t [_t_a_g]  ..  --tag=[_t_a_g]
                  Find a tag.
  -T [_t_a_g_s_f_i_l_e] --tag-file=[_t_a_g_s_f_i_l_e]
                  Use an alternate tags file.
  -u  -U  ....  --underline-special  --UNDERLINE-SPECIAL
                  Change handling of backspaces.
  -V  ........  --version
                  Display the version number of "less".
  -w  ........  --hilite-unread
                  Highlight first new line after forward-screen.
  -W  ........  --HILITE-UNREAD
                  Highlight first new line after any forward movement.
  -x [_N[,...]]  --tabs=[_N[,...]]
                  Set tab stops.
  -X  ........  --no-init
                  Don't use termcap init/deinit strings.
  -y [_N]  ....  --max-forw-scroll=[_N]
                  Forward scroll limit.
  -z [_N]  ....  --window=[_N]
                  Set size of window.
  -" [_c[_c]]  .  --quotes=[_c[_c]]
                  Set shell quote characters.
  -~  ........  --tilde
                  Don't display tildes after end of file.
  -# [_N]  ....  --shift=[_N]
                  Set horizontal scroll amount (0 = one half screen width).
                --file-size
                  Automatically determine the size of the input file.
                --follow-name
                  The F command changes files if the input file is renamed.
                --incsearch
                  Search file as each pattern character is typed in.
                --line-num-width=N
                  Set the width of the -N line number field to N characters.
                --mouse
                  Enable mouse input.
                --no-keypad
                  Don't send termcap keypad init/deinit strings.
                --no-histdups
                  Remove duplicates from command history.
                --rscroll=C
                  Set the character used to mark truncated lines.
                --save-marks
                  Retain marks across invocations of less.
                --status-col-width=N
                  Set the width of the -J status column to N characters.
                --use-backslash
                  Subsequent options use backslash as escape char.
                --use-color
                  Enables colored text.
                --wheel-lines=N
                  Each click of the mouse wheel moves N lines.


 ---------------------------------------------------------------------------

                          LLIINNEE EEDDIITTIINNGG

        These keys can be used to edit text being entered 
        on the "command line" at the bottom of the screen.

 RightArrow ..................... ESC-l ... Move cursor right one character.
 LeftArrow ...................... ESC-h ... Move cursor left one character.
 ctrl-RightArrow  ESC-RightArrow  ESC-w ... Move cursor right one word.
 ctrl-LeftArrow   ESC-LeftArrow   ESC-b ... Move cursor left one word.
 HOME ........................... ESC-0 ... Move cursor to start of line.
 END ............................ ESC-$ ... Move cursor to end of line.
 BACKSPACE ................................ Delete char to left of cursor.
 DELETE ......................... ESC-x ... Delete char under cursor.
 ctrl-BACKSPACE   ESC-BACKSPACE ........... Delete word to left of cursor.
 ctrl-DELETE .... ESC-DELETE .... ESC-X ... Delete word under cursor.
 ctrl-U ......... ESC (MS-DOS only) ....... Delete entire line.
 UpArrow ........................ ESC-k ... Retrieve previous command line.
 DownArrow ...................... ESC-j ... Retrieve next command line.
 TAB ...................................... Complete filename & cycle.
 SHIFT-TAB ...................... ESC-TAB   Complete filename & reverse cycle.
 ctrl-L ................................... Complete filename, list all.
